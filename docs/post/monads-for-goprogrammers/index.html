<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Monads for Go Programmers - Adenoid Adventures</title>
  <meta name="description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I am Bart Simpson in detention.
I suspect I am not the only one, but">
  <meta name="author" content="Walter Schulze"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Adenoid Adventures",
    
    "url": "https:\/\/awalterschulze.github.io\/blog\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/awalterschulze.github.io\/blog\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/awalterschulze.github.io\/blog\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/awalterschulze.github.io\/blog\/post\/monads-for-goprogrammers\/",
          "name": "Monads for go programmers"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Walter Schulze"
  },
  "headline": "Monads for Go Programmers",
  "description" : "Why? Monads are all about function composition and hiding the tedious part of it.\nAfter 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I am Bart Simpson in detention.\nI suspect I am not the only one, but",
  "inLanguage" : "en",
  "wordCount":  3647 ,
  "datePublished" : "2017-09-20T12:19:12",
  "dateModified" : "2017-09-20T12:19:12",
  "image" : "https:\/\/awalterschulze.github.io\/blog\/avatar.png",
  "keywords" : [ "monads, golang, generator" ],
  "mainEntityOfPage" : "https:\/\/awalterschulze.github.io\/blog\/post\/monads-for-goprogrammers\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/awalterschulze.github.io\/blog\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/awalterschulze.github.io\/blog\/avatar.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Monads for Go Programmers" />
<meta property="og:description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I am Bart Simpson in detention.
I suspect I am not the only one, but">
<meta property="og:image" content="https://awalterschulze.github.io/blog/avatar.png" />
<meta property="og:url" content="https://awalterschulze.github.io/blog/post/monads-for-goprogrammers/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Adenoid Adventures" />

  <meta name="twitter:title" content="Monads for Go Programmers" />
  <meta name="twitter:description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil â€¦">
  <meta name="twitter:image" content="https://awalterschulze.github.io/blog/avatar.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@awalterschulze" />
  <meta name="twitter:creator" content="@awalterschulze" />
  <link href='https://awalterschulze.github.io/blog/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.59.1" />
  <link rel="alternate" href="https://awalterschulze.github.io/blog/index.xml" type="application/rss+xml" title="Adenoid Adventures"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/syntax.css" /><link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-106798280-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://awalterschulze.github.io/blog/">Adenoid Adventures</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Adenoid Adventures" href="https://awalterschulze.github.io/blog/">
            <img class="avatar-img" src="https://awalterschulze.github.io/blog/avatar.png" alt="Adenoid Adventures" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Monads for Go Programmers</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on 2017 September 20
  
    &nbsp;(Last modified on 2019 July 10)
  
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Walter Schulze
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h2 id="why">Why?</h2>

<p>Monads are all about function composition and hiding the tedious part of it.</p>

<p>After 7 years of being a Go programmer, typing <code>if err != nil</code> can become quite tedious.
Everytime I type <code>if err != nil</code> I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I am Bart Simpson in detention.</p>

<p><img src="https://awalterschulze.github.io/blog/monads-for-goprogrammers/bartiferr.png" alt="Missing image of Bart Simpson writing if err != nil on the detention chalkboard" title="error detention" /></p>

<p><a href="https://anvaka.github.io/common-words/#?lang=go">I suspect I am not the only one</a>, but</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
    log.<span style="color:#06b;font-weight:bold">Printf</span>(<span style="color:#d20;background-color:#fff0f0">&#34;This should still be interesting to a Go programmer &#34;</span> +
        <span style="color:#d20;background-color:#fff0f0">&#34;considering using a functional language, despite %v.&#34;</span>, err)
}</code></pre></div>
<p>Monads are not just used to hide some error handling, but can also be used for list comprehensions and concurrency, to name but a few examples.</p>

<h2 id="don-t-read-this">Don&rsquo;t read this</h2>

<p>In Erik Meijer&rsquo;s <a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0">Introduction to Functional Programming Course on Edx</a>
he asks us to please not write another post on <code>monads</code>, since there are already so many.</p>

<p>I recommend you watch <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Bartosz Milewski&rsquo;s videos on Category Theory</a>
, which culminates in a video that is <a href="https://www.youtube.com/watch?v=gHiyzctYqZ0&amp;t=4s&amp;index=19&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">the best explanation of Monads</a> that I have ever seen,
rather than reading this post.</p>

<p>Stop reading now!</p>

<h2 id="functors">Functors</h2>

<p>Okay fine &hellip; sigh &hellip; just remember I warned you.</p>

<p>Before I can explain <code>monads</code>, I first need to explain <code>functors</code>.
A <code>functor</code> is a superclass of a <code>monad</code>, which means that all <code>monads</code> are <code>functors</code> as well.
I will use <code>functors</code> in my explanation of <code>monads</code>, so please don&rsquo;t gloss over this section.</p>

<p>We can think of a <code>functor</code> as a container, which contains one type of item.</p>

<p>Examples include:</p>

<ul>
<li>A slice with items of type T: <code>[]T</code> is a container where the items are ordered into a list.</li>
<li>A tree: <code>type Node&lt;T&gt; struct { Value T; Children: []Node&lt;T&gt; }</code> is a container whose items are structured into a tree;</li>
<li>A channel: <code>&lt;-chan T</code> is a container, like a pipe which contains water;</li>
<li>A pointer: <code>*T</code> is a container that may be empty or contain one item;</li>
<li>A function: <code>func(A) T</code> is a container, like a lock box, that first needs a key, before you can see the item;</li>
<li>Multiple return values: <code>func() (T, error)</code> is a container that possibly contains one item. We can see the error as part of the container.  From here on we will refer to <code>(T, error)</code> as a tuple.</li>
</ul>

<blockquote>
<p>Non Go programmers: Go does not have algebraic data types or union types.  This means that instead of a function returning a value <code>or</code> an error, we Go programmers return a value <code>and</code> an error, where one of them is typically nil.  Sometimes we break the convention and return a value and an error, where both are not nil, just to try and confuse one another. <a href="https://awalterschulze.github.io/blog/post/sum-types-over-multiple-returns/">Oh we have fun</a>.</p>

<p>The most popular way to have union types in Go would be to have an interface (abstract class) and then have a type switch (a very naive form of pattern matching) on the interface type.</p>
</blockquote>

<p>The other requirement for a container to be a <code>functor</code> is that we need an implementation of the <code>fmap</code> function for that container type.
The <code>fmap</code> function applies a function to each item in the container without modifying the container or structure in any way.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, aContainerOfA Container&lt;A&gt;) Container&lt;B&gt;</code></pre></div>
<p>The classic example, which you might recognize from Hadoop&rsquo;s mapreduce, Python, Ruby or almost any other language you can think of, is the <code>map</code> function for a slice:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, as []A) []B {
    bs := <span style="color:#038">make</span>([]b, <span style="color:#038">len</span>(as))
    <span style="color:#080;font-weight:bold">for</span> i, a := <span style="color:#080;font-weight:bold">range</span> as {
        bs[i] = <span style="color:#06b;font-weight:bold">f</span>(a)
    }
    <span style="color:#080;font-weight:bold">return</span> bs
}</code></pre></div>
<p>We can also implement <code>fmap</code> for a tree:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, atree Node&lt;A&gt;) Node&lt;B&gt; {
    btree := Node&lt;B&gt;{
        Value: <span style="color:#06b;font-weight:bold">f</span>(atree.Value),
        Children: <span style="color:#038">make</span>([]Node&lt;B&gt;, <span style="color:#038">len</span>(atree.Children)),
    }
    <span style="color:#080;font-weight:bold">for</span> i, c := <span style="color:#080;font-weight:bold">range</span> atree.Children {
        btree.Children[i] = <span style="color:#06b;font-weight:bold">fmap</span>(f, c)
    }
    <span style="color:#080;font-weight:bold">return</span> btree
}</code></pre></div>
<p>Or a channel:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, in &lt;-<span style="color:#080;font-weight:bold">chan</span> A) &lt;-<span style="color:#080;font-weight:bold">chan</span> B {
    out := <span style="color:#038">make</span>(<span style="color:#080;font-weight:bold">chan</span> B, <span style="color:#038">cap</span>(in))
    <span style="color:#080;font-weight:bold">go</span> <span style="color:#080;font-weight:bold">func</span>() {
        <span style="color:#080;font-weight:bold">for</span> a := <span style="color:#080;font-weight:bold">range</span> in {
            b := <span style="color:#06b;font-weight:bold">f</span>(a)
            out &lt;- b
        }
        <span style="color:#038">close</span>(out)
    }()
    <span style="color:#080;font-weight:bold">return</span> out
}</code></pre></div>
<p>Or a pointer:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, a *A) *B {
    <span style="color:#080;font-weight:bold">if</span> a == <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">nil</span>
    }
    b := <span style="color:#06b;font-weight:bold">f</span>(*a)
    <span style="color:#080;font-weight:bold">return</span> &amp;b
}</code></pre></div>
<p>Or a function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, g <span style="color:#080;font-weight:bold">func</span>(C) A) <span style="color:#080;font-weight:bold">func</span>(C) B {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(c C) B {
        a := <span style="color:#06b;font-weight:bold">g</span>(c)
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">f</span>(a)
    }
}</code></pre></div>
<p>Or a function that returns an error:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, g <span style="color:#080;font-weight:bold">func</span>() (*A, <span style="color:#888;font-weight:bold">error</span>)) <span style="color:#080;font-weight:bold">func</span>() (*B, <span style="color:#888;font-weight:bold">error</span>) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>() (*B, <span style="color:#888;font-weight:bold">error</span>) {
        a, err := <span style="color:#06b;font-weight:bold">g</span>()
        <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">nil</span>, err
        }
        b := <span style="color:#06b;font-weight:bold">f</span>(*a)
        <span style="color:#080;font-weight:bold">return</span> &amp;b, <span style="color:#080;font-weight:bold">nil</span>
    }
}</code></pre></div>
<p>All of these containers with their respective <code>fmap</code> implementations are examples of <code>functors</code>.</p>

<h2 id="function-composition">Function Composition</h2>

<p>Now that we understand that a <code>functor</code> is just:</p>

<ul>
<li>an abstract name for a container and</li>
<li>that we can apply a function to the items inside the container</li>
</ul>

<p>, we can get to the whole point: the abstract concept of a <code>monad</code>.</p>

<p>A <code>monad</code> is simply an embellished type.
Hmmm &hellip; ok that does not help to explain it, it is too abstract.
And that is typically the problem with trying to explain what a <code>monad</code> is.
Its like trying to explain what &ldquo;side effects&rdquo; are, it is just too broad.
So lets rather explain the reason for the abstraction of a <code>monad</code>.
The reason is to compose functions that return these embellished types.</p>

<p>Lets start with plain function composition, without embellished types.
In this example, we want to compose two functions <code>f</code> and <code>g</code> and return a function that takes the input that is expected by <code>f</code> and returns the output from <code>g</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) B, g <span style="color:#080;font-weight:bold">func</span>(B) C) <span style="color:#080;font-weight:bold">func</span>(A) C {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) C {
        b := <span style="color:#06b;font-weight:bold">f</span>(a)
        c := <span style="color:#06b;font-weight:bold">g</span>(b)
        <span style="color:#080;font-weight:bold">return</span> c
    }
}</code></pre></div>
<p>Obviously, this will only work if the output type of <code>f</code> matches the input type of <code>g</code>.</p>

<p>Another version of this would be composing functions that return errors.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(
    f <span style="color:#080;font-weight:bold">func</span>(*A) (*B, <span style="color:#888;font-weight:bold">error</span>), 
    g <span style="color:#080;font-weight:bold">func</span>(*B) (*C, <span style="color:#888;font-weight:bold">error</span>),
) <span style="color:#080;font-weight:bold">func</span>(*A) (*C, <span style="color:#888;font-weight:bold">error</span>) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a *A) (*C, <span style="color:#888;font-weight:bold">error</span>) {
        b, err := <span style="color:#06b;font-weight:bold">f</span>(a)
        <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">nil</span>, err
        }
        c, err := <span style="color:#06b;font-weight:bold">g</span>(b)
        <span style="color:#080;font-weight:bold">return</span> c, err
    }
}</code></pre></div>
<p>Now we can try to abstract this error as an embellishment <code>M</code> and see what we are left with:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, g <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt; {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) M&lt;C&gt; {
        mb := <span style="color:#06b;font-weight:bold">f</span>(a)
        <span style="color:#888">// ...
</span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">return</span> mc
    }
}</code></pre></div>
<p>We have to return a function that takes an <code>A</code> as an input parameter, so we start by declaring the return function.
Now that we have an <code>A</code>, we can call <code>f</code> and get and a value <code>mb</code> of type <code>M&lt;b&gt;</code>, but now what?</p>

<p>We fall short, because it is too abstract.
I mean now that we have <code>mb</code>, what do we do?</p>

<p>When we knew it was an error we could check it, but now that it is abstracted away, we can&rsquo;t.</p>

<p>But &hellip; if we know that our embellishment <code>M</code> is also a <code>functor</code>, then we can <code>fmap</code> over <code>M</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> fmap = <span style="color:#080;font-weight:bold">func</span>(<span style="color:#080;font-weight:bold">func</span>(A) B, M&lt;A&gt;) M&lt;B&gt;</code></pre></div>
<p>The function <code>g</code> that we want to <code>fmap</code> with does not return a simple type like <code>C</code> it returns <code>M&lt;C&gt;</code>.
Luckily this is not a problem for <code>fmap</code>, but it changes the type signature a bit:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> fmap = <span style="color:#080;font-weight:bold">func</span>(<span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;, M&lt;B&gt;) M&lt;M&lt;C&gt;&gt;</code></pre></div>
<p>So now we have a value <code>mmc</code> of type <code>M&lt;M&lt;C&gt;&gt;</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, g <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt; {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) M&lt;C&gt; {
        mb := <span style="color:#06b;font-weight:bold">f</span>(a)
        mmc := <span style="color:#06b;font-weight:bold">fmap</span>(g, mb)
        <span style="color:#888">// ...
</span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">return</span> mc
    }
}</code></pre></div>
<p>We need a way to go from <code>M&lt;M&lt;C&gt;&gt;</code> to <code>M&lt;C&gt;</code>.</p>

<p>We need our embellishment <code>M</code> to not just be a <code>functor</code>, but to also have another property.
This extra property is a function called <code>join</code> and is defined for each <code>monad</code>, just like <code>fmap</code> was defined for each <code>functor</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> join = <span style="color:#080;font-weight:bold">func</span>(M&lt;M&lt;C&gt;&gt;) M&lt;C&gt;</code></pre></div>
<p>Given join, we can now write:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, g <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt; {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) M&lt;C&gt; {
        mb := <span style="color:#06b;font-weight:bold">f</span>(a)
        mmc := <span style="color:#06b;font-weight:bold">fmap</span>(g, mb)
        mc := <span style="color:#06b;font-weight:bold">join</span>(mmc)
        <span style="color:#080;font-weight:bold">return</span> mc
    }
}</code></pre></div>
<p>This means we can compose two functions that return embellished types, if the embellishment defines <code>fmap</code> and <code>join</code>.
In other words, for a type to be a <code>monad</code>, these two functions need to be defined for it.</p>

<h2 id="join">Join</h2>

<p>Monads are <code>functors</code>, so we don&rsquo;t need to define <code>fmap</code> for them again.
We just need to define <code>join</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> join = <span style="color:#080;font-weight:bold">func</span>(M&lt;M&lt;C&gt;&gt;) M&lt;C&gt;</code></pre></div>
<p>We will now define <code>join</code> for:</p>

<ul>
<li>lists, which will result in list comprehensions,</li>
<li>errors, which will result in monadic error handling and</li>
<li>channels, which will result in a concurrency pipeline.</li>
</ul>

<h3 id="list-comprehensions">List Comprehensions</h3>

<p>Join on a slice is the simplest and probably the easiest to start with.
The <code>join</code> function simply concatenates all the slices.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">join</span>(ss [][]T) []T {
    s := []T{}
    <span style="color:#080;font-weight:bold">for</span> i := <span style="color:#080;font-weight:bold">range</span> ss {
        s = <span style="color:#038">append</span>(s, ss[i]...)
    }
    <span style="color:#080;font-weight:bold">return</span> s
}</code></pre></div>
<p>Lets look at why we need <code>join</code> again, but this time focusing specifically on slices.
Here is our compose function for slices:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) []B, g <span style="color:#080;font-weight:bold">func</span>(B) []C) <span style="color:#080;font-weight:bold">func</span>(A) []C {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) []C {
        bs := <span style="color:#06b;font-weight:bold">f</span>(a)
        css := <span style="color:#06b;font-weight:bold">fmap</span>(g, bs)
        cs := <span style="color:#06b;font-weight:bold">join</span>(css)
        <span style="color:#080;font-weight:bold">return</span> cs
    }
}</code></pre></div>
<p>If we pass <code>a</code> to <code>f</code> we get <code>bs</code> which is of type <code>[]B</code>.</p>

<p>We can now <code>fmap</code> over <code>[]B</code> with <code>g</code>, which will give us a value of type <code>[][]C</code> and not <code>[]C</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(g <span style="color:#080;font-weight:bold">func</span>(B) []C, bs []B) [][]C {
    css := <span style="color:#038">make</span>([][]C, <span style="color:#038">len</span>(bs))
    <span style="color:#080;font-weight:bold">for</span> i, b := <span style="color:#080;font-weight:bold">range</span> bs {
        css[i] = <span style="color:#06b;font-weight:bold">g</span>(b)
    }
    <span style="color:#080;font-weight:bold">return</span> css
}</code></pre></div>
<p>And that is why we need <code>join</code>.
We need to go from <code>css</code> to <code>cs</code> or from <code>[][]C</code> to <code>[]C</code>.</p>

<p>Lets take a look at a more concrete example:</p>

<p>If we substitute our types:</p>

<ul>
<li><code>A</code> for type <code>int</code>,</li>
<li><code>B</code> for type <code>int64</code> and</li>
<li><code>C</code> for type <code>string</code>.</li>
</ul>

<p>Then our functions become:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(<span style="color:#888;font-weight:bold">int</span>) []<span style="color:#888;font-weight:bold">int64</span>, g <span style="color:#080;font-weight:bold">func</span>(<span style="color:#888;font-weight:bold">int64</span>) []<span style="color:#888;font-weight:bold">string</span>) 
    <span style="color:#080;font-weight:bold">func</span>(<span style="color:#888;font-weight:bold">int</span>) []<span style="color:#888;font-weight:bold">string</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(g <span style="color:#080;font-weight:bold">func</span>(<span style="color:#888;font-weight:bold">int64</span>) []<span style="color:#888;font-weight:bold">string</span>, bs []<span style="color:#888;font-weight:bold">int64</span>) [][]<span style="color:#888;font-weight:bold">string</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">join</span>(css [][]<span style="color:#888;font-weight:bold">string</span>) []<span style="color:#888;font-weight:bold">string</span></code></pre></div>
<p>Now we can use them in an example:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">upto</span>(n <span style="color:#888;font-weight:bold">int</span>) []<span style="color:#888;font-weight:bold">int64</span> { 
    nums := <span style="color:#038">make</span>([]<span style="color:#888;font-weight:bold">int64</span>, n)
    <span style="color:#080;font-weight:bold">for</span> i := <span style="color:#080;font-weight:bold">range</span> nums {
        nums[i] = <span style="color:#038">int64</span>(i+<span style="color:#00d;font-weight:bold">1</span>)
    }
    <span style="color:#080;font-weight:bold">return</span> nums
}

<span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">pair</span>(x <span style="color:#888;font-weight:bold">int64</span>) []<span style="color:#888;font-weight:bold">string</span> {
    <span style="color:#080;font-weight:bold">return</span> []<span style="color:#888;font-weight:bold">string</span>{strconv.<span style="color:#06b;font-weight:bold">FormatInt</span>(x, <span style="color:#00d;font-weight:bold">10</span>), strconv.<span style="color:#06b;font-weight:bold">FormatInt</span>(-<span style="color:#00d;font-weight:bold">1</span>*x, <span style="color:#00d;font-weight:bold">10</span>)}
}

c := <span style="color:#06b;font-weight:bold">compose</span>(upto, pair)
<span style="color:#06b;font-weight:bold">c</span>(<span style="color:#00d;font-weight:bold">3</span>)
// <span style="color:#d20;background-color:#fff0f0">&#34;1&#34;</span>,<span style="color:#d20;background-color:#fff0f0">&#34;-1&#34;</span>,<span style="color:#d20;background-color:#fff0f0">&#34;2&#34;</span>,<span style="color:#d20;background-color:#fff0f0">&#34;-2&#34;</span>,<span style="color:#d20;background-color:#fff0f0">&#34;3&#34;</span>,<span style="color:#d20;background-color:#fff0f0">&#34;-3&#34;</span></code></pre></div>
<p>This makes a slice our first <code>monad</code>.</p>

<p>Interestingly this is exactly how list comprehensions work in Haskell:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">[ y | x <span style="color:#080">&lt;-</span> [<span style="color:#00d;font-weight:bold">1</span>..<span style="color:#00d;font-weight:bold">3</span>], y <span style="color:#080">&lt;-</span> [show x, show (-<span style="color:#00d;font-weight:bold">1</span> * x)] ]</code></pre></div>
<p>But you might recognize it better from Python:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-weight:bold">def</span> <span style="color:#06b;font-weight:bold">pair</span> (x):
  <span style="color:#080;font-weight:bold">return</span> [<span style="color:#038">str</span>(x), <span style="color:#038">str</span>(-<span style="color:#00d;font-weight:bold">1</span>*x)]

[y <span style="color:#080;font-weight:bold">for</span> x <span style="color:#080">in</span> <span style="color:#038">range</span>(<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">4</span>) <span style="color:#080;font-weight:bold">for</span> y <span style="color:#080">in</span> pair(x) ]</code></pre></div>
<h3 id="monadic-error-handling">Monadic Error Handling</h3>

<p>We can also define <code>join</code> on functions which return a value and an error.
For this we first need to take a step back to the <code>fmap</code> function again, because of some idiosyncrasies in Go.</p>

<p>Here is our <code>fmap</code> function again for a function that returns a value and an error:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> fmap = <span style="color:#080;font-weight:bold">func</span>(f <span style="color:#080;font-weight:bold">func</span>(B) C, g <span style="color:#080;font-weight:bold">func</span>(A) (B, <span style="color:#888;font-weight:bold">error</span>)) <span style="color:#080;font-weight:bold">func</span>(A) (C, <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>We know our compose function is going to call <code>fmap</code> with a function <code>f</code> that also returns an error.
This will result in our <code>fmap</code> signature looking something like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> fmap = <span style="color:#080;font-weight:bold">func</span>(
    f <span style="color:#080;font-weight:bold">func</span>(B) (C, <span style="color:#888;font-weight:bold">error</span>), 
    g <span style="color:#080;font-weight:bold">func</span>(A) (B, <span style="color:#888;font-weight:bold">error</span>),
) <span style="color:#080;font-weight:bold">func</span>(A) ((C, <span style="color:#888;font-weight:bold">error</span>), <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>Unfortunately tuples are not first class citizens in Go, so we can&rsquo;t write:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">((C, <span style="color:#888;font-weight:bold">error</span>), <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>There are a few ways to work around this problem.
I prefer using a function, since functions, that return a tuple, are still first class citizens:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">(<span style="color:#080;font-weight:bold">func</span>() (C, <span style="color:#888;font-weight:bold">error</span>), <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>Now we can define our <code>fmap</code> for functions which returns a value and an error, using our work around:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">fmap</span>(
    f <span style="color:#080;font-weight:bold">func</span>(B) (C, <span style="color:#888;font-weight:bold">error</span>), 
    g <span style="color:#080;font-weight:bold">func</span>(A) (B, <span style="color:#888;font-weight:bold">error</span>),
) <span style="color:#080;font-weight:bold">func</span>(A) (<span style="color:#080;font-weight:bold">func</span>() (C, <span style="color:#888;font-weight:bold">error</span>), <span style="color:#888;font-weight:bold">error</span>) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) (<span style="color:#080;font-weight:bold">func</span>() (C, <span style="color:#888;font-weight:bold">error</span>), <span style="color:#888;font-weight:bold">error</span>) {
        b, err := <span style="color:#06b;font-weight:bold">g</span>(a)
        <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
            <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">nil</span>, err
        }
        c, err := <span style="color:#06b;font-weight:bold">f</span>(b)
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>() (C, <span style="color:#888;font-weight:bold">error</span>) {
            <span style="color:#080;font-weight:bold">return</span> c, err
        }, <span style="color:#080;font-weight:bold">nil</span>
    }
}</code></pre></div>
<p>Which brings us back to our main point, our <code>join</code> function on <code>(func() (C, error), error)</code>.
Its pretty simple and simply does one of the error checks for us.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">join</span>(f <span style="color:#080;font-weight:bold">func</span>() (C, <span style="color:#888;font-weight:bold">error</span>), err <span style="color:#888;font-weight:bold">error</span>) (C, <span style="color:#888;font-weight:bold">error</span>) {
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">nil</span>, err
    }
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">f</span>()
}</code></pre></div>
<p>We can now use our compose function, since we have defined <code>join</code> and <code>fmap</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">unmarshal</span>(data []<span style="color:#888;font-weight:bold">byte</span>) (s <span style="color:#888;font-weight:bold">string</span>, err <span style="color:#888;font-weight:bold">error</span>) {
    err = json.<span style="color:#06b;font-weight:bold">Unmarshal</span>(data, &amp;s)
    <span style="color:#080;font-weight:bold">return</span>
}

getnum := <span style="color:#06b;font-weight:bold">compose</span>(
    unmarshal, 
    strconv.Atoi,
)
<span style="color:#06b;font-weight:bold">getnum</span>(<span style="color:#d20;background-color:#fff0f0">`&#34;1&#34;`</span>)
// <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#080;font-weight:bold">nil</span></code></pre></div>
<p>This results in us having to do less error checking, since the <code>monad</code> does it for us in the background using the <code>join</code> function.</p>

<p>Here is another <a href="https://speakerdeck.com/rebeccaskinner/monadic-error-handling-in-go?slide=77">example</a>, where I feel like Bart Simpson:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">upgradeUser</span>(endpoint, username <span style="color:#888;font-weight:bold">string</span>) <span style="color:#888;font-weight:bold">error</span> {
    getEndpoint := fmt.<span style="color:#06b;font-weight:bold">Sprintf</span>(<span style="color:#d20;background-color:#fff0f0">&#34;%s/oldusers/%s&#34;</span>, endpoint, username)
    postEndpoint := fmt.<span style="color:#06b;font-weight:bold">Sprintf</span>(<span style="color:#d20;background-color:#fff0f0">&#34;%s/newusers/%s&#34;</span>, endpoint, username)

    resp, err := http.<span style="color:#06b;font-weight:bold">Get</span>(genEndpoint)
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> err
    }
    data, err := ioutil.<span style="color:#06b;font-weight:bold">ReadAll</span>(resp.Body)
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> err
    }
    olduser, err := user.<span style="color:#06b;font-weight:bold">NewFromJson</span>(data)
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> err
    }
    newuser, err := user.<span style="color:#06b;font-weight:bold">NewUserFromUser</span>(olduser),
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> err
    }
    buf, err := json.<span style="color:#06b;font-weight:bold">Marshal</span>(newuser)
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> err
    }
    _, err = http.<span style="color:#06b;font-weight:bold">Post</span>(
        postEndpoint, 
        <span style="color:#d20;background-color:#fff0f0">&#34;application/json&#34;</span>, 
        bytes.<span style="color:#06b;font-weight:bold">NewBuffer</span>(buf),
    )
    <span style="color:#080;font-weight:bold">return</span> err
}</code></pre></div>
<p>Technically <code>compose</code> could take more than two functions as parameters.
That means that we could chain all the above functions together in one call and rewrite the above example:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">upgradeUser</span>(endpoint, username <span style="color:#888;font-weight:bold">string</span>) <span style="color:#888;font-weight:bold">error</span> {
    getEndpoint := fmt.<span style="color:#06b;font-weight:bold">Sprintf</span>(<span style="color:#d20;background-color:#fff0f0">&#34;%s/oldusers/%s&#34;</span>, endpoint, username)
    postEndpoint := fmt.<span style="color:#06b;font-weight:bold">Sprintf</span>(<span style="color:#d20;background-color:#fff0f0">&#34;%s/newusers/%s&#34;</span>, endpoint, username)

    _, err := <span style="color:#06b;font-weight:bold">compose</span>(
        http.Get,
        <span style="color:#080;font-weight:bold">func</span>(resp *http.Response) ([]<span style="color:#888;font-weight:bold">byte</span>, <span style="color:#888;font-weight:bold">error</span>) {
            <span style="color:#080;font-weight:bold">return</span> ioutil.<span style="color:#06b;font-weight:bold">ReadAll</span>(resp.Body)
        },
        newUserFromJson,
        newUserFromUser,
        json.Marshal,
        <span style="color:#080;font-weight:bold">func</span>(buf []<span style="color:#888;font-weight:bold">byte</span>) (*http.Response, <span style="color:#888;font-weight:bold">error</span>) {
            <span style="color:#080;font-weight:bold">return</span> http.<span style="color:#06b;font-weight:bold">Post</span>(
                postEndpoint,
                <span style="color:#d20;background-color:#fff0f0">&#34;application/json&#34;</span>,
                bytes.<span style="color:#06b;font-weight:bold">NewBuffer</span>(buf),
            )
        },
    )(getEndpoint)
    <span style="color:#080;font-weight:bold">return</span> err
}</code></pre></div>
<p>There are many other <code>monads</code> out there.
Think of any two functions that return the same type of embellishment and that you would like to compose.
Lets do one more example.</p>

<h3 id="concurrent-pipelines">Concurrent Pipelines</h3>

<p>We can also define <code>join</code> on channels.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">join</span>(in &lt;-<span style="color:#080;font-weight:bold">chan</span> &lt;-<span style="color:#080;font-weight:bold">chan</span> T) &lt;-<span style="color:#080;font-weight:bold">chan</span> T {
    out := <span style="color:#038">make</span>(<span style="color:#080;font-weight:bold">chan</span> T)
    <span style="color:#080;font-weight:bold">go</span> <span style="color:#080;font-weight:bold">func</span>() {
        wait := sync.WaitGroup{}
        <span style="color:#080;font-weight:bold">for</span> c := <span style="color:#080;font-weight:bold">range</span> in {
            wait.<span style="color:#06b;font-weight:bold">Add</span>(<span style="color:#00d;font-weight:bold">1</span>)
            <span style="color:#080;font-weight:bold">go</span> <span style="color:#080;font-weight:bold">func</span>(inner &lt;-<span style="color:#080;font-weight:bold">chan</span> T) {
                <span style="color:#080;font-weight:bold">for</span> t := <span style="color:#080;font-weight:bold">range</span> inner {
                    out &lt;- t
                }
                wait.<span style="color:#06b;font-weight:bold">Done</span>()
            }(c)
        }
        wait.<span style="color:#06b;font-weight:bold">Wait</span>()
        <span style="color:#038">close</span>(out)
    }()
    <span style="color:#080;font-weight:bold">return</span> out
}</code></pre></div>
<p>Here we have a channel <code>in</code> that will feed us more channels of type <code>T</code>.
We first create the <code>out</code> channel, start a go routine, which will be used to feed it, and then return it.
Inside the go routine we start a new go routine for each of the channels read from <code>in</code>.
These go routines send their incoming events to <code>out</code>, merging the multiple inputs into one stream.
Finally, we use a wait group to make sure we close the <code>out</code> channel once all input is received.</p>

<p>In short we are reading all <code>T</code>s from <code>in</code> and pushing them all to the <code>out</code> channel.</p>

<blockquote>
<p>Non Go programmers: I have to pass <code>c</code> as a parameter to the inner go routine, because <code>c</code> is a single variable that takes on the value of each element in the channel.  That means that if we just used it, inside the closure instead of creating a copy of the value by passing it as a parameter, we would probably only be reading from the newest channel.  <a href="https://golang.org/doc/faq#closures_and_goroutines">This is a common mistake made by go programmers</a>.</p>
</blockquote>

<p>This means we can define a compose function on functions that return channels.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) &lt;-<span style="color:#080;font-weight:bold">chan</span> B, g <span style="color:#080;font-weight:bold">func</span>(B) &lt;-<span style="color:#080;font-weight:bold">chan</span> C) <span style="color:#080;font-weight:bold">func</span>(A) &lt;-<span style="color:#080;font-weight:bold">chan</span> C {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) &lt;-<span style="color:#080;font-weight:bold">chan</span> C {
        chanOfB := <span style="color:#06b;font-weight:bold">f</span>(a)
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#06b;font-weight:bold">join</span>(<span style="color:#06b;font-weight:bold">fmap</span>(g, chanOfB))
    }
}</code></pre></div>
<p>And because of the way that <code>join</code> is implemented, we get concurrency almost for free.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">toChan</span>(lines []<span style="color:#888;font-weight:bold">string</span>) &lt;-<span style="color:#080;font-weight:bold">chan</span> <span style="color:#888;font-weight:bold">string</span> {
    c := <span style="color:#038">make</span>(<span style="color:#080;font-weight:bold">chan</span> <span style="color:#888;font-weight:bold">string</span>)
    <span style="color:#080;font-weight:bold">go</span> <span style="color:#080;font-weight:bold">func</span>() {
        <span style="color:#080;font-weight:bold">for</span> _, line := <span style="color:#080;font-weight:bold">range</span> lines {
            c &lt;- line
        }
        <span style="color:#038">close</span>(c)
    }()
    <span style="color:#080;font-weight:bold">return</span> c
}

<span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">wordsize</span>(line <span style="color:#888;font-weight:bold">string</span>) &lt;-<span style="color:#080;font-weight:bold">chan</span> <span style="color:#888;font-weight:bold">int</span> {
    removePunc := strings.<span style="color:#06b;font-weight:bold">NewReplacer</span>(
        <span style="color:#d20;background-color:#fff0f0">&#34;,&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>, 
        <span style="color:#d20;background-color:#fff0f0">&#34;&#39;&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>,
        <span style="color:#d20;background-color:#fff0f0">&#34;!&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>, 
        <span style="color:#d20;background-color:#fff0f0">&#34;.&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>, 
        <span style="color:#d20;background-color:#fff0f0">&#34;(&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>, 
        <span style="color:#d20;background-color:#fff0f0">&#34;)&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>, 
        <span style="color:#d20;background-color:#fff0f0">&#34;:&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>,
    )
    c := <span style="color:#038">make</span>(<span style="color:#080;font-weight:bold">chan</span> <span style="color:#888;font-weight:bold">int</span>)
    <span style="color:#080;font-weight:bold">go</span> <span style="color:#080;font-weight:bold">func</span>() {
        words := strings.<span style="color:#06b;font-weight:bold">Split</span>(line, <span style="color:#d20;background-color:#fff0f0">&#34; &#34;</span>)
        <span style="color:#080;font-weight:bold">for</span> _, word := <span style="color:#080;font-weight:bold">range</span> words {
            c &lt;- <span style="color:#038">len</span>(removePunc.<span style="color:#06b;font-weight:bold">Replace</span>(word))
        }
        <span style="color:#038">close</span>(c)
    }()
    <span style="color:#080;font-weight:bold">return</span> c
}

sizes := <span style="color:#06b;font-weight:bold">compose</span>(
    <span style="color:#06b;font-weight:bold">toChan</span>([]<span style="color:#888;font-weight:bold">string</span>{
        <span style="color:#d20;background-color:#fff0f0">&#34;Bart: Eat my monads!&#34;</span>,
        <span style="color:#d20;background-color:#fff0f0">&#34;Monads: I don&#39;t think that&#39;s a very good idea.&#34;</span>,
        <span style="color:#d20;background-color:#fff0f0">&#34;Lisa: If anyone wants monads, I&#39;ll be in my room.&#34;</span>,
        <span style="color:#d20;background-color:#fff0f0">&#34;Homer: Mmm monads&#34;</span>,
        <span style="color:#d20;background-color:#fff0f0">&#34;Maggie: (Pacifier Suck)&#34;</span>,
    }), 
    wordsize,
)
total := <span style="color:#00d;font-weight:bold">0</span>
<span style="color:#080;font-weight:bold">for</span> _, size := <span style="color:#080;font-weight:bold">range</span> sizes {
    <span style="color:#080;font-weight:bold">if</span> size == <span style="color:#00d;font-weight:bold">6</span> {
        total += <span style="color:#00d;font-weight:bold">1</span>
    }
}
// total == <span style="color:#00d;font-weight:bold">6</span></code></pre></div>
<h2 id="less-hand-waving">Less Hand waving</h2>

<p>This was a very hand wavy explanation of <code>monads</code> and there are many things I intentionally left out, to keep things simpler, but there is one more thing that I would like to cover.</p>

<p>Technically our compose function defined in the previous section, is called the <code>Kleisli Arrow</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> kleisliArrow = <span style="color:#080;font-weight:bold">func</span>(<span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt;</code></pre></div>
<p>When people talk about <code>monads</code> they rarely mention the <code>Kleisli Arrow</code>, which was the key for me to understanding <code>monads</code>.
If you are lucky they explain it using <code>fmap</code> and <code>join</code>, but if you are unlucky, like me, they explain it using the bind function.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> bind = <span style="color:#080;font-weight:bold">func</span>(M&lt;B&gt;, <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) M&lt;C&gt;</code></pre></div>
<p>Why?</p>

<p>Because <code>bind</code> is the function in Haskell that you need to implement for your type if you want it to be considered a <code>Monad</code>.</p>

<p>Lets repeat our implementation of the compose function here:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, g <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt; {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) M&lt;C&gt; {
        mb := <span style="color:#06b;font-weight:bold">f</span>(a)
        mmc := <span style="color:#06b;font-weight:bold">fmap</span>(g, mb)
        mc := <span style="color:#06b;font-weight:bold">join</span>(mmc)
        <span style="color:#080;font-weight:bold">return</span> mc
    }
}</code></pre></div>
<p>If the <code>bind</code> function was implemented then we could simply call it, instead of <code>fmap</code> and <code>join</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">compose</span>(f <span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, g <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt; {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">func</span>(a A) M&lt;C&gt; {
        mb := <span style="color:#06b;font-weight:bold">f</span>(a)
        mc := <span style="color:#06b;font-weight:bold">bind</span>(mb, g)
        <span style="color:#080;font-weight:bold">return</span> mc
    }
}</code></pre></div>
<p>Which means that <code>bind(mb, g)</code> = <code>join(fmap(g, mb))</code>.</p>

<p>The <code>bind</code> function for lists would be <code>concatMap</code> or <code>flatMap</code> depending on the language.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">concatMap</span>([]A, <span style="color:#080;font-weight:bold">func</span>(A) []B) []B</code></pre></div>
<h2 id="squinting">Squinting</h2>

<p>I found that Go started to blur the lines for me between <code>bind</code> and the <code>Kleisli Arrow</code>.
Go returns an error in a tuple, but a tuple is not a first class citizen.
For example, this code will not compile, because you cannot pass <code>f</code>&rsquo;s results to <code>g</code>, in an in-line way:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">f</span>() (<span style="color:#888;font-weight:bold">int</span>, <span style="color:#888;font-weight:bold">error</span>) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#080;font-weight:bold">nil</span>
}

<span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">g</span>(i <span style="color:#888;font-weight:bold">int</span>, err <span style="color:#888;font-weight:bold">error</span>, j <span style="color:#888;font-weight:bold">int</span>) <span style="color:#888;font-weight:bold">int</span> {
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">0</span>
    }
    <span style="color:#080;font-weight:bold">return</span> i + j
}

<span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">main</span>() {
    i := <span style="color:#06b;font-weight:bold">g</span>(<span style="color:#06b;font-weight:bold">f</span>(), <span style="color:#00d;font-weight:bold">1</span>)
    <span style="color:#038">println</span>(i)
}</code></pre></div>
<p>You have to write it out:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">main</span>() {
    i, err := <span style="color:#06b;font-weight:bold">f</span>()
    j := <span style="color:#06b;font-weight:bold">g</span>(i, err, <span style="color:#00d;font-weight:bold">1</span>)
    <span style="color:#038">println</span>(j)
}</code></pre></div>
<p>Or you have to make <code>g</code> take a function as input, since functions are first class citizens.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">f</span>() (<span style="color:#888;font-weight:bold">int</span>, <span style="color:#888;font-weight:bold">error</span>) {
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#080;font-weight:bold">nil</span>
}

<span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">g</span>(ff <span style="color:#080;font-weight:bold">func</span>() (<span style="color:#888;font-weight:bold">int</span>, <span style="color:#888;font-weight:bold">error</span>), j <span style="color:#888;font-weight:bold">int</span>) <span style="color:#888;font-weight:bold">int</span> {
    i, err := <span style="color:#06b;font-weight:bold">ff</span>()
    <span style="color:#080;font-weight:bold">if</span> err != <span style="color:#080;font-weight:bold">nil</span> {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">0</span>
    }
    <span style="color:#080;font-weight:bold">return</span> i + j
}

<span style="color:#080;font-weight:bold">func</span> <span style="color:#06b;font-weight:bold">main</span>() {
    i := <span style="color:#06b;font-weight:bold">g</span>(f, <span style="color:#00d;font-weight:bold">1</span>)
    <span style="color:#038">println</span>(i)
}</code></pre></div>
<p>But that means that our bind function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> bind = <span style="color:#080;font-weight:bold">func</span>(M&lt;B&gt;, <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) M&lt;C&gt;</code></pre></div>
<p>as defined for errors:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> bind = <span style="color:#080;font-weight:bold">func</span>(b B, err <span style="color:#888;font-weight:bold">error</span>, g <span style="color:#080;font-weight:bold">func</span>(B) (C, <span style="color:#888;font-weight:bold">error</span>)) (C, <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>will not be fun to use, unless we squash that tuple into a function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> bind = <span style="color:#080;font-weight:bold">func</span>(f <span style="color:#080;font-weight:bold">func</span>() (B, <span style="color:#888;font-weight:bold">error</span>), g <span style="color:#080;font-weight:bold">func</span>(B) (C, <span style="color:#888;font-weight:bold">error</span>)) (C, <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>If we squint we can see our returning tuple as a function as well:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> bind = <span style="color:#080;font-weight:bold">func</span>(f <span style="color:#080;font-weight:bold">func</span>() (B, <span style="color:#888;font-weight:bold">error</span>), g <span style="color:#080;font-weight:bold">func</span>(B) (C, <span style="color:#888;font-weight:bold">error</span>)) <span style="color:#080;font-weight:bold">func</span>() (C, <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>And if we squint again, then we can see that this is our compose function, where <code>f</code> just takes zero parameters:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> compose = <span style="color:#080;font-weight:bold">func</span>(f <span style="color:#080;font-weight:bold">func</span>(A) (B, <span style="color:#888;font-weight:bold">error</span>), g <span style="color:#080;font-weight:bold">func</span>(B) (C, <span style="color:#888;font-weight:bold">error</span>)) <span style="color:#080;font-weight:bold">func</span>(A) (C, <span style="color:#888;font-weight:bold">error</span>)</code></pre></div>
<p>Ta da, we have our <code>Kleisli Arrow</code>, by just squinting a few times.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#080;font-weight:bold">type</span> compose = <span style="color:#080;font-weight:bold">func</span>(f <span style="color:#080;font-weight:bold">func</span>(A) M&lt;B&gt;, g <span style="color:#080;font-weight:bold">func</span>(B) M&lt;C&gt;) <span style="color:#080;font-weight:bold">func</span>(A) M&lt;C&gt;</code></pre></div>
<h2 id="conclusion">Conclusion</h2>

<p>Monads hide some of the repeated logic of composing functions with embellished types, so that you don&rsquo;t have to feel like Bart Simpson in detention, but rather like Bart Simpson on his skateboard, bowling a cricket ball, while it is his turn to bat.</p>

<p><img src="https://awalterschulze.github.io/blog/monads-for-goprogrammers/bart_childhood_drawing.jpg" alt="Missing image of Bart Simpson on his skateboard" title="Lets just say, I've been a fan for a while." /></p>

<p>If you want to try <code>monads</code> and other functional programming concepts in Go, then you can do it using my code generator, <a href="https://github.com/awalterschulze/goderive">GoDerive</a>.</p>

<blockquote>
<p>Warning:  One of the key concepts of functional programming is immutability.  This not only makes programs easier to reason about, but also allows for compiler optimizations.  To simulate this immutability, in Go, you will tend to copy lots of structures that will lead to non optimal performance.  The reason functional programming languages gets away with this is exactly because they can rely on the immutability and always point to the old values, instead of copying them again.</p>

<p>If you really want to transition to functional programming, I would recommend <a href="http://elm-lang.org/">Elm</a>.  Its a statically typed functional programming language for the front-end.  It is as easy to learn for a functional language, as Go is to learn for an imperative language.  I did this <a href="https://guide.elm-lang.org/">guide</a> in a day and I was able to start being productive that evening.  The creator went out of his way to make it an easy to learn language by even removing the need to understand monads.  I have personally found <code>Elm</code> a joy to use in the front-end in conjunction with Go in back-end.  If you start feeling bored in Go and Elm, don&rsquo;t worry there is much more to learn, Haskell is waiting for you.</p>
</blockquote>

<h3 id="thank-you">Thank you</h3>

<ul>
<li><a href="https://jbrandhorst.com/">Johan Brandhorst</a> for proof reading and pushing me to write a blog.</li>
<li><a href="https://github.com/uroboros">Ryan Lemmer</a> for proof reading and the line on &ldquo;side effects&rdquo;.</li>
<li><a href="https://www.linkedin.com/in/anton-hendriks-1b549514/">Anton Hendriks</a> for proof reading and many simplifications.</li>
<li><a href="http://www.cs.sun.ac.za/~abvdm/">Brink van der Merwe</a> for proof reading.</li>
</ul>

<h3 id="referenced">Referenced</h3>

<ul>
<li><a href="https://golangweekly.com/issues/179">Golang Weekly</a></li>
</ul>


        
          <div class="blog-tags">
            
              <a href="https://awalterschulze.github.io/blog//tags/monads/">monads</a>&nbsp;
            
              <a href="https://awalterschulze.github.io/blog//tags/golang/">golang</a>&nbsp;
            
              <a href="https://awalterschulze.github.io/blog//tags/generator/">generator</a>&nbsp;
            
          </div>
        

        

        
      </article>

      
        <ul class="pager blog-pager">
          
          
            <li class="next">
              <a href="https://awalterschulze.github.io/blog/post/sum-types-over-multiple-returns/" data-toggle="tooltip" data-placement="top" title="For Sum Types: Golang&#39;s multiple return parameters are overrated">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:awalterschulze@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/awalterschulze" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/awalterschulze" title="Twitter">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/schulzewalter" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              Walter Schulze
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2019
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://awalterschulze.github.io/blog/">Adenoid Adventures</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="https://gohugo.io">Hugo v0.59.1</a> powered &nbsp;&bull;&nbsp; Theme <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> adapted from <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          &nbsp;&bull;&nbsp;[<a href="falseb2c1d70f1a79963e804794805167e43e19dead2d">b2c1d70f</a>]
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://awalterschulze.github.io/blog/js/main.js"></script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://awalterschulze.github.io/blog/js/load-photoswipe.js"></script>









    
  </body>
</html>

