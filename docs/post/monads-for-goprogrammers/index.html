<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Monads for Go Programmers</title>
  <meta property="og:title" content="Monads for Go Programmers" />
  <meta name="twitter:title" content="Monads for Go Programmers" />
  <meta name="description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I&rsquo;m Bart Simpson in detention.
I suspect I am not the only one, but">
  <meta property="og:description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I&rsquo;m Bart Simpson in detention.
I suspect I am not the only one, but">
  <meta name="twitter:description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, typing if err != nil can become quite tedious. Everytime I type if err != nil â€¦">
  <meta name="author" content="Walter Schulze"/>
  <link href='https://awalterschulze.github.io/blog/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://awalterschulze.github.io/blog/avatar.png" />
  <meta name="twitter:image" content="https://awalterschulze.github.io/blog/avatar.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://awalterschulze.github.io/blog/post/monads-for-goprogrammers/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Adenoid Adventures" />

  <meta name="generator" content="Hugo 0.25.1" />
  <link rel="canonical" href="https://awalterschulze.github.io/blog/post/monads-for-goprogrammers/" />
  <link rel="alternate" href="https://awalterschulze.github.io/blog/index.xml" type="application/rss+xml" title="Adenoid Adventures">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/main.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/pygment_highlights.css" />
  <link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/highlight.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" integrity="sha256-akwTLZec/XAFvgYgVH1T5/369lhA2Efr22xzCNl1nHs=" crossorigin="anonymous" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://awalterschulze.github.io/blog/">Adenoid Adventures</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        

        

        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Adenoid Adventures" href="https://awalterschulze.github.io/blog/">
            <img class="avatar-img" src="https://awalterschulze.github.io/blog/avatar.png" alt="Adenoid Adventures" />
          </a>
        
      </div>
    </div>

  </div>
</nav>




    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>Monads for Go Programmers</h1>
                
                
                  <span class="post-meta">
  Posted on 2017 August 26
  
</span>


                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h2 id="why">Why?</h2>

<p>Monads are all about function composition and hiding the tedious part of it.</p>

<p>After 7 years of being a Go programmer, typing <code>if err != nil</code> can become quite tedious.
Everytime I type <code>if err != nil</code> I thank the Gophers for a readable language with great tooling, but at the same time I curse them for making me feel like I&rsquo;m Bart Simpson in detention.</p>

<p><img src="http://awalterschulze.github.io/blog/monads-for-goprogrammers/bartiferr.png" alt="Missing image of Bart Simpson writing if err != nil on the detention chalkboard" title="if err != nil" /></p>

<p><a href="https://anvaka.github.io/common-words/#?lang=go">I suspect I am not the only one</a>, but</p>

<pre><code class="language-go">if err != nil {
    log.Printf(&quot;This should still be interesting to a Go programmer &quot; +
        &quot;considering using a functional language, despite %v.&quot;, err)
}
</code></pre>

<p>Monads are not just used to hide some error handling, but can also be used for list comprehensions and concurrency, to name but a few examples.</p>

<h2 id="don-t-read-this">Don&rsquo;t read this</h2>

<p>In Erik Meijer&rsquo;s <a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0">Introduction to Functional Programming Course on Edx</a>
he asks us to please not write another post on <code>monads</code>, since there are already so many.</p>

<p>I recommend you watch <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Bartosz Milewski&rsquo;s videos on Category Theory</a>
, which culminates in a video that is <a href="https://www.youtube.com/watch?v=gHiyzctYqZ0&amp;t=4s&amp;index=19&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">the best explanation of Monads</a> that I have ever seen,
rather than reading this post.</p>

<p>Stop reading now!</p>

<h2 id="functors">Functors</h2>

<p>Okay fine &hellip; sigh &hellip; just remember I warned you.</p>

<p>Before I can explain <code>monads</code>, I first need to explain <code>functors</code>.
A <code>functor</code> is a superclass of a <code>monad</code>, which means that all <code>monads</code> are <code>functors</code> as well.
I will use <code>functors</code> in my explanation of <code>monads</code>, so please don&rsquo;t gloss over this section.</p>

<p>We can think of a <code>functor</code> as a container, which contains one type of item.</p>

<p>Examples include:</p>

<ul>
<li>A slice with items of type T: <code>[]T</code> is a container where the items are ordered into a list.</li>
<li>A tree: <code>type Node&lt;T&gt; struct { Value T; Children: []Node&lt;T&gt; }</code> is a container whose items are structured into a tree;</li>
<li>A channel: <code>&lt;-chan T</code> is a container, like a pipe which contains water;</li>
<li>A pointer: <code>*T</code> is a container that may be empty or contain one item;</li>
<li>A function: <code>func(A) T</code> is a container, like a lock box, that first needs a key, before you can see the item;</li>
<li>Multiple return values: <code>func() (T, error)</code> is a container that possibly contains one item, while we can see the error as part of the container.  From here on we will refer to <code>(T, error)</code> as a tuple.</li>
</ul>

<blockquote>
<p>Non Go programmers: Go does not have algebraic data types or union types.  This means that instead of a function returning a value <code>or</code> an error, we Go programmers return a value <code>and</code> an error, where one of them is typically nil.  Sometimes we break the convention and return a value and an error, where both are not nil, just to try and confuse one another. Oh we have fun.</p>

<p>The most popular way to have union types in Go would be to have an interface (abstract class) and then have a type switch (a very naive form of pattern matching) on the interface type.</p>
</blockquote>

<p>The other requirement for a container to be a <code>functor</code> is that we need an implementation of the <code>fmap</code> function for that container type.
The <code>fmap</code> function applies a function to each item in the container without modifying the container or structure in any way.</p>

<pre><code class="language-go">func fmap(f func(A) B, aContainerOfA Container&lt;A&gt;) Container&lt;B&gt;
</code></pre>

<p>The classic example, which you might recognize from Hadoop&rsquo;s mapreduce, Python, Ruby or almost any other language you can think of, is the <code>map</code> function for a slice:</p>

<pre><code class="language-go">func fmap(f func(A) B, as []A) []B {
    bs := make([]b, len(as))
    for i, a := range as {
        bs[i] = f(a)
    }
    return bs
}
</code></pre>

<p>We can also implement <code>fmap</code> for a tree:</p>

<pre><code class="language-go">func fmap(f func(A) B, atree Node&lt;A&gt;) Node&lt;B&gt; {
    btree := Node&lt;B&gt;{
        Value: f(atree.Value),
        Children: make([]Node&lt;B&gt;, len(atree.Children)),
    }
    for i, c := range atree.Children {
        btree.Children[i] = fmap(f, c)
    }
    return btree
}
</code></pre>

<p>Or a channel:</p>

<pre><code class="language-go">func fmap(f func(A) B, in &lt;-chan A) &lt;-chan B {
	out := make(chan B, cap(in))
	go func() {
		for a := range in {
			b := f(a)
			out &lt;- b
		}
		close(out)
	}()
	return out
}
</code></pre>

<p>Or a pointer:</p>

<pre><code class="language-go">func fmap(f func(A) B, a *A) *B {
    if a == nil {
        return nil
    }
    b := f(*a)
    return &amp;b
}
</code></pre>

<p>Or a function:</p>

<pre><code class="language-go">func fmap(f func(A) B, g func(C) A) func(C) B {
    return func(c C) B {
        a := g(c)
        return f(a)
    }
}
</code></pre>

<p>Or a function that returns an error:</p>

<pre><code class="language-go">func fmap(f func(A) B, g func() (*A, error)) func() (*B, error) {
    return func() (*B, error) {
        a, err := g()
        if err != nil {
            return nil, err
        }
        b := f(*a)
        return &amp;b, nil
    }
}
</code></pre>

<p>All of these containers with their respective <code>fmap</code> implementations are examples of <code>functors</code>.</p>

<h2 id="function-composition">Function Composition</h2>

<p>Now that we understand that a <code>functor</code> is just:</p>

<ul>
<li>an abstract name for a container and</li>
<li>that we can apply a function to the items inside the container</li>
</ul>

<p>, we can get to the whole point: the abstract concept of a <code>monad</code>.</p>

<p>A <code>monad</code> is simply an embellished type.
Hmmm &hellip; ok that does not help to explain it, it is too abstract.
And that is typically the problem with trying to explain what a <code>monad</code> is.
Its like trying to explain what &ldquo;side effects&rdquo; are, it is just too broad.
So lets rather explain the reason for the abstraction of a <code>monad</code>.
The reason is to compose functions that return these embellished types.</p>

<p>Lets start with plain function composition, without embellished types.
In this example, we want to compose two functions <code>f</code> and <code>g</code> and return a function that takes the input that is expected by <code>f</code> and returns the output from <code>g</code>:</p>

<pre><code class="language-go">func compose(f func(A) B, g func(B) C) func(A) C {
    return func(a A) c {
        b := f(a)
        c := g(b)
        return c
    }
}
</code></pre>

<p>Obviously, this will only work if the output type of <code>f</code> matches the input type of <code>g</code>.</p>

<p>Another version of this would be composing functions that return errors.</p>

<pre><code class="language-go">func compose(f func(*A) (*B, error), g func(*B) (*C, error)) 
    func(*A) (*C, error) {
    return func(a *A) (*C, error) {
        b, err := f(a)
        if err != nil {
            return nil, err
        }
        c, err := g(b)
        return c, err
    }
}
</code></pre>

<p>Now we can try to abstract this error as an embellishment <code>M</code> and see what we are left with:</p>

<pre><code class="language-go">func compose(f func(A) M&lt;B&gt;, g func(B) M&lt;C&gt;) func(A) M&lt;C&gt; {
    return func(a A) M&lt;C&gt; {
        mb := f(a)
        // ...
        return mc
    }
}
</code></pre>

<p>We have to return a function that takes an <code>a</code> as an input parameter, so we start by declaring the return function.
Now that we have an <code>a</code>, we can call <code>f</code> and get and a value <code>mb</code> of type <code>M&lt;b&gt;</code>, but now what?</p>

<p>We fall short, because it is too abstract.
I mean now that we have <code>mb</code>, what do we do?</p>

<p>When we knew it was an error we could check it, but now that it is abstracted away, we can&rsquo;t.</p>

<p>But &hellip; if we know that our embellishment <code>M</code> is also a <code>functor</code>, then we can <code>fmap</code> over <code>M</code>:</p>

<pre><code class="language-go">type fmap = func(func(A) B, M&lt;A&gt;) M&lt;B&gt;
</code></pre>

<p>The function <code>g</code> that we want to <code>fmap</code> with does not return a simple type like <code>C</code> it returns <code>M&lt;C&gt;</code>.
Luckily this is not a problem for <code>fmap</code>, but it changes the type signature a bit:</p>

<pre><code class="language-go">type fmap = func(func(B) M&lt;C&gt;, M&lt;B&gt;) M&lt;M&lt;C&gt;&gt;
</code></pre>

<p>So now we have a value <code>mmc</code> of type <code>M&lt;M&lt;C&gt;&gt;</code>:</p>

<pre><code class="language-go">func compose(f func(A) M&lt;B&gt;, g func(B) M&lt;C&gt;) func(A) M&lt;C&gt; {
    return func(a A) M&lt;C&gt; {
        mb := f(a)
        mmc := fmap(g, mb)
        // ...
        return mc
    }
}
</code></pre>

<p>We need a way to go from <code>M&lt;M&lt;C&gt;&gt;</code> to <code>M&lt;C&gt;</code>.</p>

<p>We need our embellishment <code>M</code> to not just be a <code>functor</code>, but to also have another property.
This extra property is a function called <code>join</code> and is defined for each <code>monad</code>, just like <code>fmap</code> was defined for each <code>functor</code>.</p>

<pre><code class="language-go">type join = func(M&lt;M&lt;C&gt;&gt;) M&lt;C&gt;
</code></pre>

<p>Given join, we can now write:</p>

<pre><code class="language-go">func compose(f func(A) M&lt;B&gt;, g func(B) M&lt;C&gt;) func(A) M&lt;C&gt; {
    return func(a A) M&lt;C&gt; {
        mb := f(a)
        mmc := fmap(g, mb)
        mc := join(mmc)
        return mc
    }
}
</code></pre>

<p>This means we can compose two functions that return embellished types, if the embellishment defines <code>fmap</code> and <code>join</code>.
These two functions are required to be defined for a type, for that type to be a <code>monad</code>.</p>

<h2 id="join">Join</h2>

<p>Monads are <code>functors</code>, so we don&rsquo;t need to define <code>fmap</code> for them again.
We just need to define <code>join</code>.</p>

<pre><code class="language-go">type join = func(M&lt;M&lt;C&gt;&gt;) M&lt;C&gt;
</code></pre>

<p>We will now define <code>join</code> for:</p>

<ul>
<li>lists, which will result in list comprehensions,</li>
<li>errors, which will result in monadic error handling and</li>
<li>channels, which will result in a concurrency pipeline.</li>
</ul>

<h3 id="list-comprehensions">List Comprehensions</h3>

<p>Join on a slice is the simplest and probably the easiest to start with.
The <code>join</code> function simply concatenates all the slices.</p>

<pre><code class="language-go">func join(ss [][]T) []T {
    s := []T{}
    for i := range ss {
        s = append(s, ss[i]...)
    }
    return s
}
</code></pre>

<p>Lets look at why we need <code>join</code> again, but focusing specifically on slices.
Here is our compose function again, but this time defined specifically for slices.</p>

<pre><code class="language-go">func compose(f func(A) []B, g func(B) []C) func(A) []C {
    return func(a A) []C {
        bs := f(a)
        css := fmap(g, bs)
        cs := join(css)
        return cs
    }
}
</code></pre>

<p>If we pass <code>a</code> to <code>f</code> we get <code>bs</code> which is of type <code>[]B</code>.</p>

<p>We can now <code>fmap</code> over <code>[]B</code> with <code>g</code>, which will give us a value of type <code>[][]C</code> and not <code>[]C</code>:</p>

<pre><code class="language-go">func fmap(g func(B) []C, bs []B) [][]C {
    css := make([][]C, len(bs))
    for i, b := range bs {
        css[i] = g(b)
    }
    return css
}
</code></pre>

<p>And that is why we need <code>join</code>.
We need to go from <code>css</code> to <code>cs</code> or from <code>[][]C</code> to <code>[]C</code>.</p>

<p>Lets take a look at a more concrete example:</p>

<p>If we substitute our types:</p>

<ul>
<li><code>A</code> for type <code>int</code>,</li>
<li><code>B</code> for type <code>int64</code> and</li>
<li><code>C</code> for type <code>string</code>.</li>
</ul>

<p>Then our functions become:</p>

<pre><code class="language-go">func compose(f func(int) []int64, g func(int64) []string) 
    func(int) []string
</code></pre>

<pre><code class="language-go">func fmap(g func(int64) []string, bs []int64) [][]string
</code></pre>

<pre><code class="language-go">func join(css [][]string) []string
</code></pre>

<p>And then we can use them in our example:</p>

<pre><code class="language-go">func upto(n int) []int64 { 
    nums := make([]int64, n)
    for i := range nums {
        nums[i] = int64(i+1)
    }
    return nums
}

func pair(x int64) []string {
    return []int{strconv.FormatInt(x, 10), strconv.FormatInt(-1*x, 10)}
}

c := compose(upto, pair)
c(3)
// &quot;1&quot;,&quot;-1&quot;,&quot;2&quot;,&quot;-2&quot;,&quot;3&quot;,&quot;-3&quot;
</code></pre>

<p>This makes a slice our first <code>monad</code>.</p>

<p>Interestingly this is exactly how list comprehensions work in Haskell:</p>

<pre><code class="language-haskell">[ y | x &lt;- [1..3], y &lt;- [show x, show (-1 * x)] ]
</code></pre>

<p>But might know them from Python:</p>

<pre><code class="language-python">def pair (x):
  return [str(x), str(-1*x)]

[y for x in range(1,4) for y in pair(x) ]
</code></pre>

<h3 id="monadic-error-handling">Monadic Error Handling</h3>

<p>We can also define <code>join</code> on functions which return a value and an error.
For this we first need to take a step back to the <code>fmap</code> function again, because of some idiosyncrasies in Go.</p>

<pre><code class="language-go">type fmap = func(f func(B) C, g func(A) (B, error)) func(A) (C, error)
</code></pre>

<p>We know our compose function is going to call <code>fmap</code> with a function <code>f</code> that also returns an error.
This will result in our <code>fmap</code> signature looking something like this:</p>

<pre><code class="language-go">type fmap = func(f func(A) (C, error), g func(A) (B, error)) 
    func(A) ((C, error), error)
</code></pre>

<p>Unfortunately tuples are not first class citizens in Go, so we can&rsquo;t write:</p>

<pre><code class="language-go">((C, error), error)
</code></pre>

<p>There are a few ways to work around this problem.
I prefer using a function, since a function that returns a tuple is still a first class citizen:</p>

<pre><code class="language-go">(func() (C, error), error)
</code></pre>

<p>Now we can define our <code>fmap</code> for functions which returns a value and an error, using our work around:</p>

<pre><code class="language-go">func fmap(f func(B) (C, error), g func(A) (B, error)) 
    func(A) (func() (C, error), error) {
    return func(a A) (func() (C, error), error) {
        b, err := g(a)
        if err != nil {
            return nil, err
        }
        return func() (C, error) {
            return f(b)
        }
    }
}
</code></pre>

<p>Which brings us back to our main point, our <code>join</code> function on <code>(func() (c, error), error)</code>.
Its pretty simple and simply does one of the error checks for us.</p>

<pre><code class="language-go">func join(f func() (C, error), err error) (C, error) {
    if err != nil {
        return nil, err
    }
    return f()
}
</code></pre>

<p>We can now use our compose function, since we have defined <code>join</code> and <code>fmap</code>:</p>

<pre><code class="language-go">func unmarshal(data []byte) (s string, err error) {
    err = json.Unmarshal(data, &amp;s)
    return
}

getnum := compose(
    unmarshal, 
    strconv.Atoi,
)
getnum(`&quot;1&quot;`)
// 1, nil
</code></pre>

<p>This results in us having to do less error checking, since the <code>monad</code> does it for us in the background using the <code>join</code> function.</p>

<p>Here is another <a href="https://speakerdeck.com/rebeccaskinner/monadic-error-handling-in-go?slide=77">example</a>, where I feel like Bart Simpson:</p>

<pre><code class="language-go">func upgradeUser(endpoint, username string) error {
    getEndpoint := fmt.Sprintf(&quot;%s/oldusers/%s&quot;, endpoint, username)
    postEndpoint := fmt.Sprintf(&quot;%s/newusers/%s&quot;, endpoint, username)

    req, err := http.Get(genEndpoint)
    if err != nil {
        return err
    }
    data, err := ioutil.ReadAll(req.Body)
    if err != nil {
        return err
    }
    olduser, err := user.NewFromJson(data)
    if err != nil {
        return err
    }
    newuser, err := user.NewUserFromUser(olduser),
    if err != nil {
        return err
    }
    buf, err := json.Marshal(newuser)
    if err != nil {
        return err
    }
    _, err = http.Post(
        postEndpoint, 
        &quot;application/json&quot;, 
        bytes.NewBuffer(buf,
    )
    return err
}
</code></pre>

<p>Technically <code>compose</code> could take more than two functions as parameters.
That means that we could chain all the above functions together in one call and rewrite the above example:</p>

<pre><code class="language-go">func upgradeUser(endpoint, username string) error {
    getEndpoint := fmt.Sprintf(&quot;%s/oldusers/%s&quot;, endpoint, username)
    postEndpoint := fmt.Sprintf(&quot;%s/newusers/%s&quot;, endpoint, username)

    _, err := compose(
		http.Get,
		func(req *http.Response) ([]byte, error) {
			return ioutil.ReadAll(req.Body)
		},
		newUserFromJson,
		newUserFromUser,
		json.Marshal,
		func(buf []byte) (*http.Response, error) {
			return http.Post(
				postEndpoint,
				&quot;application/json&quot;,
				bytes.NewBuffer(buf),
			)
		},
	)(getEndpoint)
    return err
}
</code></pre>

<p>There are many other <code>monads</code> out there.
Think of any two functions that you want to compose that return the same type of embellishment.
Lets do one more example.</p>

<h3 id="concurrent-pipelines">Concurrent Pipelines</h3>

<p>We can also define <code>join</code> on channels.</p>

<pre><code class="language-go">func join(in &lt;-chan &lt;-chan T) &lt;-chan T {
	out := make(chan T)
	go func() {
		wait := sync.WaitGroup{}
		for c := range in {
			wait.Add(1)
			go func(inner &lt;-chan T) {
				for t := range inner {
					out &lt;- t
				}
				wait.Done()
			}(c)
		}
		wait.Wait()
		close(out)
	}()
	return out
}
</code></pre>

<p>Here we have a channel <code>in</code> that will feed us more channels of type <code>T</code>.
We first create our <code>out</code> channel and start up a go routine which we are going to use to feed the channel with and then return the <code>out</code> channel.
Inside the go routine we start up a new go routine for each incoming channel that we are reading from <code>in</code>.
This inner go routines will be used to listen to incoming events on a single channel and send all of these events to the <code>out</code> channel.
Then we wait for all the channels to be closed and close the <code>out</code> channel.</p>

<p>In short we are reading all <code>T</code>s from <code>in</code> and pushing them all to the <code>out</code> channel.</p>

<blockquote>
<p>Non Go programmers: I have to pass <code>c</code> as a parameter to the inner go routine, because <code>c</code> is a single variable that takes on the value of each element in the channel.  That means that if we just used it, inside the closure instead of creating a copy of the value by passing it as a parameter, we would probably only be reading from the newest channel.  <a href="https://golang.org/doc/faq#closures_and_goroutines">This is a common mistake made by go programmers</a>.</p>
</blockquote>

<p>This means we can define a compose function on functions that return channels.</p>

<pre><code class="language-go">func compose(f func(A) &lt;-chan B, g func(B) &lt;-chan C) func(A) &lt;-chan C {
	return func(a A) &lt;-chan C {
		b := f(a)
		return join(fmap(g, b))
	}
}
</code></pre>

<p>And because of the way that <code>join</code> is implemented, we get concurrency almost for free.</p>

<pre><code class="language-go">func toChan(lines []string) &lt;-chan string {
	c := make(chan string)
	go func() {
		for _, line := range lines {
			c &lt;- line
		}
		close(c)
	}()
	return c
}

func wordsize(line string) &lt;-chan int {
	c := make(chan int)
	go func() {
		words := strings.Split(line, &quot; &quot;)
		for _, word := range words {
			c &lt;- len(word)
		}
		close(c)
	}()
	return c
}

sizes := compose(
    toChan([]string{
        &quot;my name is judge&quot;,
        &quot;welcome judy welcome judy&quot;,
        &quot;welcome hello welcome judy&quot;,
        &quot;welcome goodbye welcome judy&quot;,
    }), 
    wordsize,
)
total := 0
for _, size := range sizes {
    total += size
}
// total == 83
</code></pre>

<h2 id="less-hand-waving">Less Hand waving</h2>

<p>This was a very hand wavy explanation of <code>monads</code> and there are many things I intentionally left out, to keep things simpler, but there is one more thing that I would like to cover.</p>

<p>Technically our compose function defined in the previous section, is called the <code>Kleisli Arrow</code>.</p>

<pre><code class="language-go">type kleisliArrow = func(func(A) M&lt;B&gt;, func(B) M&lt;C&gt;) func(A) M&lt;C&gt;
</code></pre>

<p>When people talk about <code>monads</code> they rarely mention the <code>Kleisli Arrow</code>, which was the key for me to understanding <code>monads</code>.
If you are lucky they explain it using <code>fmap</code> and <code>join</code>, but if you are unlucky, like me, they explain it using the bind function.</p>

<pre><code class="language-go">type bind = func(M&lt;B&gt;, func(B) M&lt;C&gt;) M&lt;C&gt;
</code></pre>

<p>Why?</p>

<p>Because <code>bind</code> is the function in Haskell that you need to implement for your type if you want it to be considered a <code>Monad</code>.</p>

<p>Lets repeat our implementation of the compose function here:</p>

<pre><code class="language-go">func compose(f func(A) M&lt;B&gt;, g func(B) M&lt;C&gt;) func(A) M&lt;C&gt; {
    return func(a A) M&lt;C&gt; {
        mb := f(a)
        mmc := fmap(g, mb)
        mc := join(mmc)
        return mc
    }
}
</code></pre>

<p>If the <code>bind</code> function was implemented then we could simply call it, instead of <code>fmap</code> and <code>join</code>.</p>

<pre><code class="language-go">func compose(f func(A) M&lt;B&gt;, g func(B) M&lt;C&gt;) func(A) M&lt;C&gt; {
    return func(a A) M&lt;C&gt; {
        mb := f(a)
        mc := bind(mb, g)
        return mc
    }
}
</code></pre>

<p>Which means that <code>bind(mb, g)</code> = <code>join(fmap(g, mb))</code>.</p>

<p>The <code>bind</code> function for lists would be <code>concatMap</code> or <code>flatMap</code> depending on the language.</p>

<pre><code class="language-go">func concatMap([]A, func(A) []B) []B
</code></pre>

<h2 id="squinting">Squinting</h2>

<p>I found that Go started to blur the lines for me between <code>bind</code> and the <code>Kleisli Arrow</code>.
Go returns an error in a tuple, but a tuple is not a first class citizen.
For example this code will not compile, because you cannot pass <code>f</code>&rsquo;s results to <code>g</code>, in an in-line way:</p>

<pre><code class="language-go">func f() (int, error) {
    return 1, nil
}

func g(i int, err error, j int) int {
    if err != nil {
        return 0
    }
    return i + j
}

func main() {
    i := g(f(), 1)
    println(i)
}
</code></pre>

<p>You have to write it out:</p>

<pre><code class="language-go">func main() {
    i, err := f()
    j := g(i, err, 1)
    println(j)
}
</code></pre>

<p>Or you have to make <code>g</code> take a function as input, since functions are first class citizens.</p>

<pre><code class="language-go">func f() (int, error) {
    return 1, nil
}

func g(ff func() (int, error), j int) int {
    i, err := ff()
    if err != nil {
        return 0
    }
    return i + j
}

func main() {
    i := g(f, 1)
    println(i)
}
</code></pre>

<p>But that means that our bind function:</p>

<pre><code class="language-go">type bind = func(M&lt;B&gt;, func(B) M&lt;C&gt;) M&lt;C&gt;
</code></pre>

<p>as defined for errors:</p>

<pre><code class="language-go">type bind = func(b B, err error, g func(B) (C, error)) (C, error)
</code></pre>

<p>will not be fun to use, unless we squash that tuple into a function:</p>

<pre><code class="language-go">type bind = func(f func() (B, error), g func(B) (C, error)) (C, error)
</code></pre>

<p>If we squint we can see our returning tuple as a function as well:</p>

<pre><code class="language-go">type bind = func(f func() (B, error), g func(B) (C, error)) func() (C, error)
</code></pre>

<p>And if we squint again, then we can see that this is our compose function, where <code>f</code> just takes zero parameters:</p>

<pre><code class="language-go">type compose = func(f func(A) (B, error), g func(B) (C, error)) func(A) (C, error)
</code></pre>

<p>Ta da, we have our <code>Kleisli Arrow</code>, by just squinting a few times.</p>

<pre><code class="language-go">type compose = func(f func(A) M&lt;B&gt;, g func(B) M&lt;C&gt;) func(A) M&lt;C&gt;
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Monads hide some of the repeated logic of composing functions with embellished types, so that you don&rsquo;t have to feel like Bart Simpson in detention, but rather like Bart Simpson on his skateboard.</p>

<p><img src="http://awalterschulze.github.io/blog/monads-for-goprogrammers/bartskate.jpg" alt="Missing image of Bart Simpson on his skateboard" title="separation of church and skate" /></p>

<p>If you want to try <code>monads</code> and other functional programming concepts in Go, then you can do it using my code generator, <a href="https://github.com/awalterschulze/goderive">GoDerive</a>.</p>

<blockquote>
<p>Warning:  One of the key concepts of functional programming is immutability.  This not only makes programs easier to reason about, but also allows for compiler optimizations.  To simulate this immutability, in Go, you will tend to copy lots of structures that will lead to non optimal performance.  The reason functional programming languages gets away with this is exactly because they can rely on the immutability and always point to the old values, instead of copying them again.</p>

<p>If you really want to transition to functional programming, I would recommend <a href="http://elm-lang.org/">Elm</a>.  Its a statically typed functional programming language for the front-end.  It is as easy to learn as is Go to learn for an imperative language.  I did this <a href="https://guide.elm-lang.org/">guide</a> in a day and I was able to start being productive that evening.  The creator went out of his way to make it an easy to learn language by even removing the need to understand monads.  I have personally found <code>Elm</code> a joy to use in the front-end in conjunction with Go in back-end.  If you start feeling bored in Go and Elm, don&rsquo;t worry there is much more to learn, Haskell is waiting for you.</p>
</blockquote>

<p>Thank you:</p>

<ul>
<li><a href="https://jbrandhorst.com/">Johan Brandhorst</a> for proof reading and pushing me to write a blog.</li>
<li><a href="https://github.com/uroboros">Ryan Lemmer</a> for proof reading and the line on &ldquo;side effects&rdquo;.</li>
<li><a href="https://www.linkedin.com/in/anton-hendriks-1b549514/">Anton Hendriks</a> for proof reading.</li>
</ul>

      </article>

      <ul class="pager blog-pager">
        
          <li class="previous">
            <a href="https://awalterschulze.github.io/blog/post/go-experience-report/" data-toggle="tooltip" data-placement="top" title="Go Experience Report: from a code generator developer [DRAFT]">&larr; Previous Post</a>
          </li>
        
        
      </ul>

      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:awalterschulze@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/awalterschulze" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/schulzewalter" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="https://awalterschulze.github.io/blog/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          Walter Schulze
          &nbsp;&bull;&nbsp;
          2017

          
            &nbsp;&bull;&nbsp;
            <a href="https://awalterschulze.github.io/blog/">Adenoid Adventures</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.25.1</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://awalterschulze.github.io/blog/js/main.js"></script>
<script src="https://awalterschulze.github.io/blog/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js" integrity="sha256-WxYLWg8NFyyEq+Zs9pVsDQmlFpJt+733DecPx5+hrQw=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js" integrity="sha256-LVuWfOU0rWFMCJNl1xb3K2HSWfxtK4IPbqEerP1P83M=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/protobuf.min.js" integrity="sha256-Le3u1m9hxZl5N1mYD82YrFSvjbzappFUesMsvgCFXTE=" crossorigin="anonymous"></script>

<script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>
<script src="https://awalterschulze.github.io/blog/js/load-photoswipe.js"></script>



  </body>
</html>

