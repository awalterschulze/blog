<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Monads for Go Programmers</title>
  <meta property="og:title" content="Monads for Go Programmers" />
  <meta name="twitter:title" content="Monads for Go Programmers" />
  <meta name="description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, the amount of times I have had to type if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling,but at the same time I curse them for making me feel like I&rsquo;m Bart Simpson in detention.">
  <meta property="og:description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, the amount of times I have had to type if err != nil can become quite tedious. Everytime I type if err != nil I thank the Gophers for a readable language with great tooling,but at the same time I curse them for making me feel like I&rsquo;m Bart Simpson in detention.">
  <meta name="twitter:description" content="Why? Monads are all about function composition and hiding the tedious part of it.
After 7 years of being a Go programmer, the amount of times I have had to type if err != nil can become quite tedious. â€¦">
  <meta name="author" content="Walter Schulze"/>
  <link href='https://awalterschulze.github.io/blog/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://awalterschulze.github.io/blog/avatar.png" />
  <meta name="twitter:image" content="https://awalterschulze.github.io/blog/avatar.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://awalterschulze.github.io/blog/post/monads-for-goprogrammers/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Adenoid Adventures" />

  <meta name="generator" content="Hugo 0.25.1" />
  <link rel="canonical" href="https://awalterschulze.github.io/blog/post/monads-for-goprogrammers/" />
  <link rel="alternate" href="https://awalterschulze.github.io/blog/index.xml" type="application/rss+xml" title="Adenoid Adventures">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/main.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/pygment_highlights.css" />
  <link rel="stylesheet" href="https://awalterschulze.github.io/blog/css/highlight.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" integrity="sha256-akwTLZec/XAFvgYgVH1T5/369lhA2Efr22xzCNl1nHs=" crossorigin="anonymous" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://awalterschulze.github.io/blog/">Adenoid Adventures</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        

        

        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Adenoid Adventures" href="https://awalterschulze.github.io/blog/">
            <img class="avatar-img" src="https://awalterschulze.github.io/blog/avatar.png" alt="Adenoid Adventures" />
          </a>
        
      </div>
    </div>

  </div>
</nav>




    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>Monads for Go Programmers</h1>
                
                
                  <span class="post-meta">
  Posted on 2017 August 26
  
</span>


                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h2 id="why">Why?</h2>

<p>Monads are all about function composition and hiding the tedious part of it.</p>

<p>After 7 years of being a Go programmer, the amount of times I have had to type <code>if err != nil</code> can become quite tedious.
Everytime I type <code>if err != nil</code> I thank the Gophers for a readable language with great tooling,but at the same time I curse them for making me feel like I&rsquo;m Bart Simpson in detention.</p>

<p><img src="http://awalterschulze.github.io/blog/monads-for-goprogrammers/bartiferr.png" alt="Missing image of Bart Simpson writing if err != nil on the detention chalkboard" title="if err != nil" /></p>

<p><a href="https://anvaka.github.io/common-words/#?lang=go">I suspect I am not the only one</a>, but</p>

<pre><code class="language-go">if err != nil {
    log.Printf(&quot;This should still be interesting for a go programmer &quot; +
        &quot;considering to use a functional language, despite %v.&quot;, err)
}
</code></pre>

<p>Monads are not just used to hide some error handling, but can also be used for list comprehension and concurrency, to name but a few.</p>

<h2 id="don-t-read-this">Don&rsquo;t read this</h2>

<p>In Erik Meijer&rsquo;s <a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0">Introduction to Functional Programming Course on Edx</a>
he asks us to please not write another post on <code>monads</code>, since there are already so many.</p>

<p>I recommend you watch <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Bartosz Milewski&rsquo;s videos on Category Theory</a>
, which culminates in a video that is <a href="https://www.youtube.com/watch?v=gHiyzctYqZ0&amp;t=4s&amp;index=19&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">the best explanation of Monads</a> that I have ever seen,
rather than reading this post.</p>

<p>Stop reading now!</p>

<h2 id="functors">Functors</h2>

<p>Okay fine &hellip; sigh &hellip; just remember I warned you.</p>

<p>Before I can explain <code>monads</code>, I first need to explain <code>functors</code>.
A <code>functor</code> is a superclass of a <code>monad</code>, which means that all <code>monads</code> are <code>functors</code> as well.
I will use <code>functors</code> in my explanation of <code>monads</code>, so please don&rsquo;t gloss over this section.</p>

<p>We can think of a <code>functor</code> as a container, which contains one parametric type.</p>

<p>Examples include:</p>

<ul>
<li>A slice with parametric type T: <code>[]T</code> is a container where the items are ordered into a list.</li>
<li>A tree: <code>type Node&lt;T&gt; struct { Value T; Children: []Node&lt;T&gt; }</code> is a container whose items are structured into a tree;</li>
<li>A channel with parametric type T: <code>&lt;-chan T</code> is a container, like a pipe which contains water;</li>
<li>A pointer: <code>*T</code> is a container that may be empty or contain one item;</li>
<li>A function: <code>func(a) T</code> is a container, like a lock box, that first needs a key, before you can see the item;</li>
<li>A tuple: <code>(T, error)</code> is a container that possibly contains one item with a possible error in the container as well.</li>
</ul>

<blockquote>
<p>Non go programmers: Go does not have algebriac data types or union types.  This means that instead of a function returning a value <code>or</code> an error, we go programmers return a value <code>and</code> an error, where one of them is typically nil.  Sometimes we break the convention and return a value and an error, where both are not nil, just to try and confuse one another. Oh we have fun.</p>

<p>The most popular way to have union types in go would be have an interface (abstract class) and then have a type switch (a very naive form of pattern matching) on the interface type.</p>
</blockquote>

<p>The other requirement for a container to be a <code>functor</code> is that we need an implementation of the <code>fmap</code> function for that container type.
The <code>fmap</code> function applies a function to each item in the container without modifying the container or structure in any way.</p>

<pre><code class="language-text">func fmap(f func(a) b, aContainerOfa Container&lt;a&gt;) Container&lt;b&gt;
</code></pre>

<p>The classic example, which you might recognize from Hadoop&rsquo;s mapreduce, Python, Ruby or almost any other language you can think of, is the <code>map</code> function for a slice:</p>

<pre><code class="language-go">func fmap(f func(a) b, as []a) []b {
    bs := make([]b, len(as))
    for i, a := range as {
        bs[i] = f(a)
    }
    return bs
}
</code></pre>

<p>We can also implement <code>fmap</code> for a tree:</p>

<pre><code class="language-text">func fmap(f func(a) b, atree Node&lt;a&gt;) Node&lt;b&gt; {
    btree := Node&lt;b&gt;{
        Value: f(atree.Value),
        Children: make([]Node&lt;b&gt;, len(atree.Children)),
    }
    for i, c := range atree.Children {
        btree.Children[i] = fmap(f, c)
    }
    return btree
}
</code></pre>

<p>Or a channel:</p>

<pre><code class="language-go">func fmap(f func(A) B, in &lt;-chan A) &lt;-chan B {
	out := make(chan B, cap(in))
	go func() {
		for a := range in {
			b := f(a)
			out &lt;- b
		}
		close(out)
	}()
	return out
}
</code></pre>

<p>Or a pointer:</p>

<pre><code class="language-go">func fmap(f func(a) b, a *a) *b {
    if a == nil {
        return nil
    }
    b := f(*a)
    return &amp;b
}
</code></pre>

<p>Or a function:</p>

<pre><code class="language-go">func fmap(f func(a) b, g func(c) a) func(c) b {
    return func(c c) b {
        a := g(c)
        return f(a)
    }
}
</code></pre>

<p>Or a function that returns an error:</p>

<pre><code class="language-go">func fmap(f func(a) b, g func() (*a, error)) func() (*b, error) {
    return func() (*b, error) {
        a, err := g()
        if err != nil {
            return nil, err
        }
        b := f(*a)
        return &amp;b, nil
    }
}
</code></pre>

<p>All of these containers with their respective <code>fmap</code> implementations are examples of <code>functors</code>.</p>

<h2 id="function-composition">Function Composition</h2>

<p>Now that we understand that a <code>functor</code> is just:
  - an abstract name for a container and
  - that we can apply a function to the items inside the container
, we can get to the whole point: the abstract concept of a <code>monad</code>.</p>

<p>A <code>monad</code> is simply an embellished type.
Hmmm &hellip; ok that does not help to explain it, its too abstract.
And that is typically the problem with trying to explain what a <code>monad</code> is.
Its like trying to explain what &ldquo;side effects&rdquo; are, its just too broad.
So lets rather explain the reason for the abstraction of a <code>monad</code>.
The reason is to compose functions that return these embellished types.</p>

<p>Lets start with plain function composition, without embellished types.
In this example, we want to compose two functions <code>f</code> and <code>g</code> and return a function that takes the input that is expected by <code>f</code> and return the output from <code>g</code>:</p>

<pre><code class="language-go">func compose(f func(a) b, g func(b) c) func(a) c {
    return func(a a) c {
        b := f(a)
        c := g(b)
        return c
    }
}
</code></pre>

<p>Obviously, this will only work if the output type of <code>f</code> matches the input type of <code>g</code>.</p>

<p>Another version of this would be composing functions that return errors.</p>

<pre><code class="language-go">func compose(f func(*a) (*b, error), g func(*b) (*c, error)) func(*a) (*c, error) {
    return func(a *a) (*c, error) {
        b, err := f(a)
        if err != nil {
            return nil, err
        }
        c, err := g(b)
        return c, err
    }
}
</code></pre>

<p>Now we can try to abstract this error as an embellishment <code>M</code> and see what we are left with:</p>

<pre><code class="language-text">func compose(f func(a) M&lt;b&gt;, g func(b) M&lt;c&gt;) func(a) M&lt;c&gt; {
    return func(a a) M&lt;c&gt; {
        mb := f(a)
        // ...
        return mc
    }
}
</code></pre>

<p>We have to return a function that takes an <code>a</code> as an input parameter, so we start by declaring the return function.
Now that we have an <code>a</code>, we can call <code>f</code> and get and a value <code>mb</code> of type <code>M&lt;b&gt;</code>, but now what?</p>

<p>We fall short, because its too abstract.
I mean now that we have <code>mb</code>, what do we do?</p>

<p>When we knew it was an error we could check it, but now that its abstracted away, we can&rsquo;t.</p>

<p>But &hellip; if we know that our embellishment <code>M</code> is also a <code>functor</code>, then we can <code>fmap</code> over <code>M</code>:</p>

<pre><code class="language-text">type fmap = func(func(a) b, M&lt;a&gt;) M&lt;b&gt;
</code></pre>

<p>The function <code>g</code> that we want to <code>fmap</code> with does not return a simple type like <code>c</code> it returns <code>M&lt;c&gt;</code>.
Luckily this is not a problem for <code>fmap</code>, but it changes the type signature a bit:</p>

<pre><code class="language-text">type fmap = func(func(b) M&lt;c&gt;, M&lt;b&gt;) M&lt;M&lt;c&gt;&gt;
</code></pre>

<p>So now we have a value <code>mmc</code> of type <code>M&lt;M&lt;c&gt;&gt;</code>:</p>

<pre><code class="language-text">func compose(f func(a) M&lt;b&gt;, g func(b) M&lt;c&gt;) func(a) M&lt;c&gt; {
    return func(a a) M&lt;c&gt; {
        mb := f(a)
        mmc := fmap(g, mb)
        // ...
        return mc
    }
}
</code></pre>

<p>We need a way to go from <code>M&lt;M&lt;c&gt;&gt;</code> to <code>M&lt;c&gt;</code>.</p>

<p>We need our embellishment <code>M</code> to not just be a <code>functor</code>, but to also have another property.
This extra property is a function called <code>join</code> and is defined for each <code>monad</code>, just like <code>fmap</code> was defined for each <code>functor</code>.</p>

<pre><code class="language-text">type join = func(M&lt;M&lt;c&gt;&gt;) M&lt;c&gt;
</code></pre>

<p>Given join, we can now write:</p>

<pre><code class="language-text">func compose(f func(a) M&lt;b&gt;, g func(b) M&lt;c&gt;) func(a) M&lt;c&gt; {
    return func(a a) M&lt;c&gt; {
        mb := f(a)
        mmc := fmap(g, mb)
        mc := join(mmc)
        return mc
    }
}
</code></pre>

<p>This means we can compose two functions that return embellished types, if the embellishment defines <code>fmap</code> and <code>join</code>.
These two functions are required to be defined for a type, for that type to be a <code>monad</code>.</p>

<h2 id="join">Join</h2>

<p>Monads are <code>functors</code>, so we don&rsquo;t need to define <code>fmap</code> for them again.
We just need to define <code>join</code>.</p>

<pre><code class="language-text">type join = func(M&lt;M&lt;c&gt;&gt;) M&lt;c&gt;
</code></pre>

<p>We will now define <code>join</code> for:
  - lists, which will result in list comprehensions,
  - errors, which will result in monadic error handling and
  - channels, which will result in a concurrency pipeline.</p>

<h3 id="list-comprehension">List Comprehension</h3>

<p>Join on a slice is the simplest probably the easiest to start with.
The <code>join</code> function simply concatenates all the slices.</p>

<pre><code class="language-go">func join(ss [][]T) []T {
    s := []T{}
    for i := range ss {
        s = append(s, ss[i]...)
    }
    return s
}
</code></pre>

<p>This means we can define compose on functions that return slices.</p>

<pre><code class="language-go">type compose = func(func(a) []b, func(b) []c) func(a) []c
</code></pre>

<p>And that makes a slice our first <code>monad</code>.
Here is an example:</p>

<pre><code class="language-go">func upto(n int) []int { 
    nums := make([]int, n)
    for i := range nums {
        nums[i] = i+1
    }
    return nums
}

func pair(x int) []int {
    return []int{x, -1*x}
}

c := compose(upto, pair)
c(3)
// 1,-1,2,-2,3,-3
</code></pre>

<p>This is exactly how list comprehensions work in Haskell:</p>

<pre><code class="language-haskell">[ y | x &lt;- [1..4], y &lt;- pair x ]
</code></pre>

<p>And in Python:</p>

<pre><code class="language-python">def pair (x):
  return [x, -1*x]

[y for x in range(1,4) for y in pair(x) ]
</code></pre>

<h3 id="monadic-error-handling">Monadic Error Handling</h3>

<p>We can also define <code>join</code> on functions which return a value and an error.
For this we first need to take a step back to the <code>fmap</code> function again, because of some idiosyncrasies in go.</p>

<pre><code class="language-go">type fmap = func(f func(b) c, g func(a) (b, error)) func(a) (c, error)
</code></pre>

<p>We know our compose function is going to call <code>fmap</code> with a function <code>f</code> that also returns an error.
This will result in our <code>fmap</code> signature looking something like this:</p>

<pre><code class="language-go">type fmap = func(f func(b) (c, error), g func(a) (b, error)) func(a) ((c, error), error)
</code></pre>

<p>Unfortunately tuples are not first class citizens in go, so we can&rsquo;t write:</p>

<pre><code class="language-go">((c, error), error)
</code></pre>

<p>There are a few ways to work around this problem.
I prefer using a function, since a function that returns a tuple is still a first class citizen:</p>

<pre><code class="language-go">(func() (c, error), error)
</code></pre>

<p>Now we can define our <code>fmap</code> for functions which returns a value and an error, using our work around:</p>

<pre><code class="language-go">func fmap(f func(b) (c, error), g func(a) (b, error)) func(a) (func() (c, error), error) {
    return func(a a) (func() (c, error), error) {
        b, err := g(a)
        if err != nil {
            return nil, err
        }
        return func() (c, error) {
            return f(b)
        }
    }
}
</code></pre>

<p>Which brings us back to our main point, our <code>join</code> function on <code>(func() (c, error), error)</code>.
Its pretty simple and simply does one of the error checks for us.</p>

<pre><code class="language-go">func join(f func() (c, error), err error) (c, error) {
    if err != nil {
        return nil, err
    }
    return f()
}
</code></pre>

<p>We can now use our compose function, since we have defined <code>join</code> and <code>fmap</code>:</p>

<pre><code class="language-go">func unmarshal(data []byte) (s string, err error) {
    err = json.Unmarshal(data, &amp;s)
    return
}

getnum := compose(
    unmarshal, 
    strconv.Atoi,
)
getnum(`&quot;1&quot;`)
// 1, nil
</code></pre>

<p>This results in us having to do less error checking, since the <code>monad</code> does it for us in the background using the <code>join</code> function.</p>

<p>There are many other <code>monads</code> out there.
Think of any two functions that you want to compose that return the same type of embellishment.
Lets do one more example.</p>

<h3 id="concurrent-pipelines">Concurrent Pipelines</h3>

<p>We can also define <code>join</code> on channels.</p>

<pre><code class="language-go">func join(in &lt;-chan &lt;-chan T) &lt;-chan T {
	out := make(chan T)
	go func() {
		wait := sync.WaitGroup{}
		for c := range in {
			wait.Add(1)
			res := c
			go func() {
				for r := range res {
					out &lt;- r
				}
				wait.Done()
			}()
		}
		wait.Wait()
		close(out)
	}()
	return out
}
</code></pre>

<p>Here have a channel <code>in</code> that will feed us more channels of type <code>T</code>.
We first create our <code>out</code> channel and start up a go routine which we are going to use to feed the channel with and then return the <code>out</code> channel.
Inside the go routine we start up a new go routine for each incoming channel that we are reading from <code>in</code>.
This inner go routines will be used to listen to incoming events on a single channel and send all of these events to the <code>out</code> channel.
Then we wait for all the channels to be closed and close the <code>out</code> channel.</p>

<p>In short we are reading all <code>T</code>s from <code>in</code> and pushing them all to the <code>out</code> channel.</p>

<p>This means we can define a compose function on functions that return channels.</p>

<pre><code class="language-go">func compose(f func(A) &lt;-chan B, g func(B) &lt;-chan C) func(A) &lt;-chan C {
	return func(a A) &lt;-chan C {
		b := f(a)
		return join(fmap(g, b))
	}
}
</code></pre>

<p>And because of the way that <code>join</code> is implemented, we get concurrency almost for free.</p>

<pre><code class="language-go">func toChan(lines []string) &lt;-chan string {
	c := make(chan string)
	go func() {
		for _, line := range lines {
			c &lt;- line
		}
		close(c)
	}()
	return c
}

func wordsize(line string) &lt;-chan int {
	c := make(chan int)
	go func() {
		words := strings.Split(line, &quot; &quot;)
		for _, word := range words {
			c &lt;- len(word)
		}
		close(c)
	}()
	return c
}

sizes := compose(
    toChan([]string{
        &quot;my name is judge&quot;,
        &quot;welcome judy welcome judy&quot;,
        &quot;welcome hello welcome judy&quot;,
        &quot;welcome goodbye welcome judy&quot;,
    }), 
    wordsize,
)
total := 0
for _, size := range sizes {
    total += size
}
// total == 83
</code></pre>

<h2 id="less-hand-waving">Less Hand waving</h2>

<p>This was a very hand wavy explanation of <code>monads</code> and there are many things I intentionally left out, to keep things simpler, but there is one thing that I would like to cover.</p>

<p>Technically our compose function defined in the previous section, is called the <code>Kleisli</code> arrow.</p>

<pre><code class="language-text">type kleisliArrow = func(func(a) M&lt;b&gt;, func(b) M&lt;c&gt;) func(a) M&lt;c&gt; {
</code></pre>

<p>When people talk about <code>monads</code> they rarely mention the <code>Kleisli</code> arrow, which was the key for me to understanding <code>monads</code>.
If you are lucky they explain it using <code>fmap</code> and <code>join</code>, but if you are unlucky, like me, they explain it using the bind function.</p>

<pre><code class="language-text">type bind = func(M&lt;b&gt;, func(b) M&lt;c&gt;) M&lt;c&gt;
</code></pre>

<p>Why?</p>

<p>Because this is the <code>mappend</code> or <code>&gt;&gt;=</code> function in Haskell that you need to implement for your type to be consider of the <code>Monad</code> type class.</p>

<p>Lets repeat our implementation of the compose function here:</p>

<pre><code class="language-text">func compose(f func(a) M&lt;b&gt;, g func(b) M&lt;c&gt;) func(a) M&lt;c&gt; {
    return func(a a) M&lt;c&gt; {
        mb := f(a)
        mmc := fmap(g, mb)
        mc := join(mmc)
        return mc
    }
}
</code></pre>

<p>If the bind function was implemented then we could simply call it instead of <code>fmap</code> and <code>join</code>.</p>

<pre><code class="language-text">func compose(f func(a) M&lt;b&gt;, g func(b) M&lt;c&gt;) func(a) M&lt;c&gt; {
    return func(a a) M&lt;c&gt; {
        mb := f(a)
        mc := bind(mb, g)
        return mc
    }
}
</code></pre>

<p>Which means that <code>bind(mb, g)</code> = <code>join(fmap(g, mb))</code>.</p>

<p>The <code>bind</code> function for lists would be <code>concatMap</code> or <code>flatMap</code> depending on the language.</p>

<pre><code class="language-go">func concatMap(as []a, func(a) []b) []b
</code></pre>

<h2 id="squinting">Squinting</h2>

<p>I found that go started to blur the lines for me between <code>bind</code> and <code>Kleisli</code>.
Go returns an error in a tuple, but a tuple is not a first class citizen.
For example this code will not compile:</p>

<pre><code class="language-go">func f() (int, error) {
    return 1, nil
}

func g(i int, err error, j int) int {
    if err != nil {
        return 0
    }
    return i + j
}

func main() {
    i := g(f(), 1)
    println(i)
}
</code></pre>

<p>, because you cannot pass <code>f</code>&rsquo;s results to <code>g</code>, in an in-line way.
You have to write it out:</p>

<pre><code class="language-go">func main() {
    i, err := f()
    j := g(i, err, 1)
    println(j)
}
</code></pre>

<p>Or you have to make <code>g</code> take a function as input, since functions are first class citizens.</p>

<pre><code class="language-go">func f() (int, error) {
    return 1, nil
}

func g(ff func() (int, error), j int) int {
    i, err := ff()
    if err != nil {
        return 0
    }
    return i + j
}

func main() {
    i := g(f, 1)
    println(i)
}
</code></pre>

<p>But that means that our bind function:</p>

<pre><code class="language-text">type bind = func(M&lt;b&gt;, func(b) M&lt;c&gt;) M&lt;c&gt;
</code></pre>

<p>as defined for errors:</p>

<pre><code class="language-go">type bind = func(b, error, func(b) (c, error)) (c, error)
</code></pre>

<p>will not be fun to use, unless we squash that tuple into a function:</p>

<pre><code class="language-go">type bind = func(func() (b, error), func(b) (c, error)) (c, error)
</code></pre>

<p>It we squint we can see our returning tuple as a function as well:</p>

<pre><code class="language-go">type bind = func(f func() (b, error), g func(b) (c, error)) func() (c, error)
</code></pre>

<p>And if we squint again, then we can see that this is our compose function, where <code>f</code> just takes zero parameters:</p>

<pre><code class="language-go">type compose = func(f func(a) (b, error), g func(b) (c, error)) func(a) (c, error)
</code></pre>

<p>Ta da, we have our <code>Kleisli</code> arrow, by just squinting a few times.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Monads hide some of the repeated logic of composing functions with embellished types, so that you don&rsquo;t have to feel like Bart Simpson in detention, but rather like Bart Simpson on his skateboard.</p>

<p><img src="http://awalterschulze.github.io/blog/monads-for-goprogrammers/bartskate.jpg" alt="Missing image of Bart Simpson on his skateboard" title="separation of church and skate" /></p>

<p>If you want to try <code>monads</code> and other functional programming concepts in go, then you can do it using my code generator, <a href="https://github.com/awalterschulze/goderive">GoDerive</a>.</p>

<blockquote>
<p>Warning:  One of the key concepts of functional programming is immutability.  This not only makes programs easier to reason about, but also allows for compiler optimizations.  To simulate this immutability, in Go, you will tend to copy lots of structures that will lead to non optimal performance.  The reason functional programming languages gets away with this is exactly because they can rely on the immutability and always point to the old values, instead of copying them again.</p>

<p>If you really want to transition to functional programming, I would recommend <a href="http://elm-lang.org/">Elm</a>.  Its a statically typed functional programming language for the front-end.  It is as easy to learn as is Go to learn for an imperative language.  I did this <a href="https://guide.elm-lang.org/">guide</a> in a day and I was able to start being productive that evening.  The creator went out of his way to make it an easy to learn language by even removing the need to understand monads.  I have personally found <code>Elm</code> a joy to use in the front-end in conjunction with Go in back-end.  If you start feeling bored in Go and Elm, don&rsquo;t worry there is much more to learn, Haskell is waiting for you.</p>
</blockquote>

      </article>

      <ul class="pager blog-pager">
        
        
      </ul>

      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:awalterschulze@gmail.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/awalterschulze" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/schulzewalter" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="https://awalterschulze.github.io/blog/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          Walter Schulze
          &nbsp;&bull;&nbsp;
          2017

          
            &nbsp;&bull;&nbsp;
            <a href="https://awalterschulze.github.io/blog/">Adenoid Adventures</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.25.1</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://awalterschulze.github.io/blog/js/main.js"></script>
<script src="https://awalterschulze.github.io/blog/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js" integrity="sha256-WxYLWg8NFyyEq+Zs9pVsDQmlFpJt+733DecPx5+hrQw=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js" integrity="sha256-LVuWfOU0rWFMCJNl1xb3K2HSWfxtK4IPbqEerP1P83M=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/protobuf.min.js" integrity="sha256-Le3u1m9hxZl5N1mYD82YrFSvjbzappFUesMsvgCFXTE=" crossorigin="anonymous"></script>

<script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>
<script src="https://awalterschulze.github.io/blog/js/load-photoswipe.js"></script>



  </body>
</html>

